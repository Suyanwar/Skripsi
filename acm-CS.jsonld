{
  "@context": {
    "acm": "http://localhost:5000/acm/",
    "id": "acm:id",
    "name": "acm:name",
    "hasChild": "acm:hasChild",
    "code": "acm:code",
    "tier1": "acm:tier1",
    "tier2": "acm:tier2",
    "isElectives": "acm:isElectives",
    "hasTopicsCT1": {
      "@id": "acm:hasTopicsCT1",
      "@container": "@set"
   },
    "hasTopicsCT2": {
      "@id": "acm:hasTopicsCT2",
      "@container": "@set"
   },
    "hasOutcomesCT1": {
      "@id": "acm:hasOutcomesCT1",
      "@container": "@set"
   },
    "hasOutcomesCT2": {
      "@id": "acm:hasOutcomesCT2",
      "@container": "@set"
   }
  },
  "@graph": [
      {
          "@id": "AL",
          "name": "Algorithms and Complexity",
          "id": "AL",
          "hasChild": [
              {
                  "code": "AL/Basic Analysis",
                  "tier1": "2",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Differences among best, expected, and worst case behaviors of an algorithm",
                      "Asymptotic analysis of upper and expected complexity bounds",
                      "Big O notation: formal definition",
                      "Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential",
                      "Empirical measurements of performance",
                      "Time and space trade-offs in algorithms"
                  ],
                  "hasTopicsCT2": [
                      "Big O notation: use",
                      "Little o, big omega and big theta notation",
                      "Recurrence relations",
                      "Analysis of iterative and recursive algorithms",
                      "Some version of a Master Theorem"
                  ],
                  "hasOutcomesCT1": [
                      "Explain what is meant by “best”, “expected”, and “worst” case behavior of an algorithm",
                      "In the context of specific algorithms, identify the characteristics of data and/or other conditions or assumptions that lead to different behaviors",
                      "Determine informally the time and space complexity of simple algorithms",
                      "State the formal definition of big O",
                      "List and contrast standard complexity classes",
                      "Perform empirical studies to validate hypotheses about runtime stemming from mathematical analysis. Run algorithms on input of various sizes and compare performance",
                      "Give examples that illustrate time-space trade-offs of algorithms"
                  ],
                  "hasOutcomesCT2": [
                      "Use big O notation formally to give asymptotic upper bounds on time and space complexity of algorithms",
                      "Use big O notation formally to give expected case bounds on time complexity of algorithms",
                      "Explain the use of big omega, big theta, and little o notation to describe the amount of work done by an algorithm",
                      "Use recurrence relations to determine the time complexity of recursively defined algorithms",
                      "Solve elementary recurrence relations, e.g., using some form of a Master Theorem"
                  ]
              },
              {
                  "code": "AL/Algorithmic Strategies",
                  "tier1": "5",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Brute-force algorithms",
                      "Greedy algorithms",
                      "Divide-and-conquer",
                      "Recursive backtracking",
                      "Dynamic Programming"
                  ],
                  "hasTopicsCT2": [
                      "Branch-and-bound",
                      "Heuristics",
                      "Reduction: transform-and-conquer"
                  ],
                  "hasOutcomesCT1": [
                      "For each of the strategies (brute-force, greedy, divide-and-conquer, recursive backtracking, and dynamic programming), identify a practical example to which it would apply",
                      "Use a greedy approach to solve an appropriate problem and determine if the greedy rule chosen leads to an optimal solution",
                      "Use a divide-and-conquer algorithm to solve an appropriate problem",
                      "Use recursive backtracking to solve a problem such as navigating a maze",
                      "Use dynamic programming to solve an appropriate problem",
                      "Determine an appropriate algorithmic approach to a problem"
                  ],
                  "hasOutcomesCT2": [
                      "Describe various heuristic problem-solving methods",
                      "Use a heuristic approach to solve an appropriate problem",
                      "Describe the trade-offs between brute force and heuristic strategies",
                      "Describe how a branch-and-bound approach may be used to improve the performance of a heuristic method"
                  ]
              },
              {
                  "code": "AL/Fundamental Data Structures and Algorithms",
                  "tier1": "9",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max, and mode in a list, approximating the square root of a number, or finding the greatest common divisor",
                      "Sequential and binary search algorithms",
                      "Worst case quadratic sorting algorithms (selection, insertion)",
                      "Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort)",
                      "Hash tables, including strategies for avoiding and resolving collisions",
                      "Common operations on binary search trees such as select min, max, insert, delete, iterate over tree",
                      "Representations of graphs (e.g., adjacency list, adjacency matrix)",
                      "Depth- and breadth-first traversals"
                  ],
                  "hasTopicsCT2": [
                      "Heaps",
                      "Shortest-path algorithms (Dijkstra’s and Floyd’s algorithms)",
                      "Minimum spanning tree (Prim’s and Kruskal’s algorithms)",
                      "Pattern matching and string/text algorithms (e.g., substring matching, regular expression matching, longest common subsequence algorithms)"
                  ],
                  "hasOutcomesCT1": [
                      "Implement basic numerical algorithms",
                      "Implement simple search algorithms and explain the differences in their time complexities",
                      "Be able to implement common quadratic and O(N log N) sorting algorithms",
                      "Describe the implementation of hash tables, including collision avoidance and resolution",
                      "Discuss the runtime and memory efficiency of principal algorithms for sorting, searching, and hashing",
                      "Discuss factors other than computational efficiency that influence the choice of algorithms, such as programming time, maintainability, and the use of application-specific patterns in the input data",
                      "Explain how tree balance affects the efficiency of various binary search tree operations",
                      "Solve problems using fundamental graph algorithms, including depth-first and breadth-first search",
                      "Demonstrate the ability to evaluate algorithms, to select from a range of possible options, to provide justification for that selection, and to implement the algorithm in a particular context"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the heap property and the use of heaps as an implementation of priority queues",
                      "Solve problems using graph algorithms, including single-source and all-pairs shortest paths, and at least one minimum spanning tree algorithm",
                      "Trace and/or implement a string-matching algorithm"
                  ]
              },
              {
                  "code": "AL/Basic Automata Computability and Complexity",
                  "tier1": "3",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Finite-state machines",
                      "Regular expressions",
                      "The halting problem"
                  ],
                  "hasTopicsCT2": [
                      "Context-free grammars",
                      "Introduction to the P and NP classes and the P vs. NP problem",
                      "Introduction to the NP-complete class and exemplary NP-complete problems (e.g., SAT, Knapsack)"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the concept of finite state machines",
                      "Design a deterministic finite state machine to accept a specified language",
                      "Generate a regular expression to represent a specified language",
                      "Explain why the halting problem has no algorithmic solution"
                  ],
                  "hasOutcomesCT2": [
                      "Design a context-free grammar to represent a specified language",
                      "Define the classes P and NP",
                      "Explain the significance of NP-completeness"
                  ]
              },
              {
                  "code": "AL/Advanced Computational Complexity",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Review of the classes P and NP; introduce P-space and EXP",
                      "Polynomial hierarchy",
                      "NP-completeness (Cook’s theorem)"
                  ],
                  "hasTopicsCT2": [
                      "Classic NP-complete problems",
                      "Reduction Techniques"
                  ],
                  "hasOutcomesCT1": [
                      "Define the classes P and NP. (Also appears in AL/Basic Automata, Computability, and Complexity)",
                      "Define the P-space class and its relation to the EXP class",
                      "Explain the significance of NP-completeness. (Also appears in AL/Basic Automata, Computability, and Complexity)"
                  ],
                  "hasOutcomesCT2": [
                      "Provide examples of classic NP-complete problems",
                      "Prove that a problem is NP-complete by reducing a classic known NP-complete problem to it"
                  ]
              },
              {
                  "code": "AL/Advanced Automata Theory and Computability",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Regular languages",
                      "Review of deterministic finite automata (DFAs)",
                      "Nondeterministic finite automata (NFAs)",
                      "Equivalence of DFAs and NFAs",
                      "Review of regular expressions; their equivalence to finite automata",
                      "Closure properties",
                      "Proving languages non-regular, via the pumping lemma or alternative means",
                      "Push-down automata (PDAs)",
                      "Relationship of PDAs and context-free grammars"
                  ],
                  "hasTopicsCT2": [
                      "Properties of context-free languages",
                      "Turing machines, or an equivalent formal model of universal computation",
                      "Nondeterministic Turing machines",
                      "Chomsky hierarchy",
                      "The Church-Turing thesis",
                      "Computability",
                      "Rice’s Theorem",
                      "Examples of uncomputable functions",
                      "Implications of uncomputability"
                  ],
                  "hasOutcomesCT1": [
                      "Determine a language’s place in the Chomsky hierarchy (regular, context-free, recursively enumerable)",
                      "Convert among equivalently powerful notations for a language, including among DFAs, NFAs, and regular expressions, and between PDAs and CFGs",
                      "Explain the Church-Turing thesis and its significance"
                  ],
                  "hasOutcomesCT2": [
                      "Explain Rice’s Theorem and its significance",
                      "Provide examples of uncomputable functions",
                      "Prove that a problem is uncomputable by reducing a classic known uncomputable problem to it"
                  ]
              },
              {
                  "code": "AL/Advanced Data Structures Algorithms and Analysis",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Balanced trees (e.g., AVL trees, red-black trees, splay trees, treaps)",
                      "Graphs (e.g., topological sort, finding strongly connected components, matching)",
                      "Advanced data structures (e.g., B-trees, Fibonacci heaps)",
                      "String-based data structures and algorithms (e.g., suffix arrays, suffix trees, tries)",
                      "Network flows (e.g., max flow [Ford-Fulkerson algorithm], max flow – min cut, maximum bipartite matching)",
                      "Linear Programming (e.g., duality, simplex method, interior point algorithms)",
                      "Number-theoretic algorithms (e.g., modular arithmetic, primality testing, integer factorization)"
                  ],
                  "hasTopicsCT2": [
                      "Geometric algorithms (e.g., points, line segments, polygons. [properties, intersections], finding convex hull, spatial decomposition, collision detection, geometric search/proximity)",
                      "Randomized algorithms",
                      "Stochastic algorithms",
                      "Approximation algorithms",
                      "Amortized analysis",
                      "Probabilistic analysis",
                      "Online algorithms and competitive analysis"
                  ],
                  "hasOutcomesCT1": [
                      "Understand the mapping of real-world problems to algorithmic solutions (e.g., as graph problems, linear programs, etc.)",
                      "Select and apply advanced algorithmic techniques (e.g., randomization, approximation) to solve real problems"
                  ],
                  "hasOutcomesCT2": [
                      "Select and apply advanced analysis techniques (e.g., amortized, probabilistic, etc.) to algorithms"
                  ]
              }
          ]
      },
      {
          "@id": "AR",
          "name": "Architecture and Organization",
          "id": "AR",
          "hasChild": [
              {
                  "code": "AR/Digital Logic and Digital Systems",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Overview and history of computer architecture",
                      "Combinational vs. sequential logic/Field programmable gate arrays as a fundamental combinational + sequential logic building block",
                      "Multiple representations/layers of interpretation (hardware is just another layer)",
                      "Computer-aided design tools that process hardware and architectural representations",
                      "Register transfer notation/Hardware Description Language (Verilog/VHDL)",
                      "Physical constraints (gate delays, fan-in, fan-out, energy/power)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the progression of computer technology components from vacuum tubes to VLSI, from mainframe computer architectures to the organization of warehouse-scale computers",
                      "Comprehend the trend of modern computer architectures towards multi-core and that parallelism is inherent in all hardware systems",
                      "Explain the implications of the “power wall” in terms of further processor performance improvements and the drive towards harnessing parallelism",
                      "Articulate that there are many equivalent representations of computer functionality, including logical expressions and gates, and be able to use mathematical expressions to describe the functions of simple combinational and sequential circuits",
                      "Design the basic building blocks of a computer: arithmetic-logic unit (gate-level), registers (gate-level), central processing unit (register transfer-level), memory (register transfer-level)",
                      "Use CAD tools for capture, synthesis, and simulation to evaluate simple building blocks (e.g., arithmetic-logic unit, registers, movement between registers) of a simple computer design",
                      "Evaluate the functional and timing diagram behavior of a simple processor implemented at the logic circuit level"
                  ]
              },
              {
                  "code": "AR/Machine Level Representation of Data",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Bits, bytes, and words",
                      "Numeric data representation and number bases",
                      "Fixed- and floating-point systems",
                      "Signed and twos-complement representations",
                      "Representation of non-numeric data (character codes, graphical data)",
                      "Representation of records and arrays"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain why everything is data, including instructions, in computers",
                      "Explain the reasons for using alternative formats to represent numerical data",
                      "Describe how negative integers are stored in sign-magnitude and twos-complement representations",
                      "Explain how fixed-length number representations affect accuracy and precision",
                      "Describe the internal representation of non-numeric data, such as characters, strings, records, and arrays",
                      "Convert numerical data from one format to another",
                      "Write simple programs at the assembly/machine level for string processing and manipulation"
                  ]
              },
              {
                  "code": "AR/Assembly Level Machine Organization",
                  "tier1": "0",
                  "tier2": "6",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Basic organization of the von Neumann machine",
                      "Control unit; instruction fetch, decode, and execution",
                      "Instruction sets and types (data manipulation, control, I/O)",
                      "Assembly/machine language programming",
                      "Instruction formats",
                      "Addressing modes",
                      "Subroutine call and return mechanisms",
                      "I/O and interrupts",
                      "Heap vs. Static vs. Stack vs. Code segments",
                      "Shared memory multiprocessors/multicore organization",
                      "Introduction to SIMD vs. MIMD and the Flynn Taxonomy"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain the organization of the classical von Neumann machine and its major functional units",
                      "Describe how an instruction is executed in a classical von Neumann machine, with extensions for threads, multiprocessor synchronization, and SIMD execution",
                      "Describe instruction level parallelism and hazards, and how they are managed in typical processor pipelines",
                      "Summarize how instructions are represented at both the machine level and in the context of a symbolic assembler",
                      "Demonstrate how to map between high-level language patterns into assembly/machine language notations",
                      "Explain different instruction formats, such as addresses per instruction and variable length vs. fixed length formats",
                      "Explain how subroutine calls are handled at the assembly level",
                      "Explain the basic concepts of interrupts and I/O operations",
                      "Write simple assembly language program segments",
                      "Show how fundamental high-level programming constructs are implemented at the machine-language level"
                  ]
              },
              {
                  "code": "AR/Memory System Organization and Architecture",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Storage systems and their technology",
                      "Memory hierarchy: importance of temporal and spatial locality",
                      "Main memory organization and operations",
                      "Latency, cycle time, bandwidth, and interleaving",
                      "Cache memories (address mapping, block size, replacement and store policy)",
                      "Multiprocessor cache consistency/Using the memory system for inter-core synchronization/atomic memory operations",
                      "Virtual memory (page table, TLB)",
                      "Fault handling and reliability",
                      "Error coding, data compression, and data integrity"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Identify the main types of memory technology (e.g., SRAM, DRAM, Flash, magnetic disk) and their relative cost and performance",
                      "Explain the effect of memory latency on running time",
                      "Describe how the use of memory hierarchy (cache, virtual memory) is used to reduce the effective memory latency",
                      "Describe the principles of memory management",
                      "Explain the workings of a system with virtual memory management",
                      "Compute Average Memory Access Time under a variety of cache and memory configurations and mixes of instruction and data references"
                  ]
              },
              {
                  "code": "AR/Interfacing and Communication",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "I/O fundamentals: handshaking, buffering, programmed I/O, interrupt-driven I/O",
                      "Interrupt structures: vectored and prioritized, interrupt acknowledgment",
                      "External storage, physical organization, and drives",
                      "Buses: bus protocols, arbitration, direct-memory access (DMA)",
                      "Introduction to networks: communications networks as another layer of remote access",
                      "Multimedia support",
                      "RAID architectures"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain how interrupts are used to implement I/O control and data transfers",
                      "Identify various types of buses in a computer system",
                      "Describe data access from a magnetic disk drive",
                      "Compare common network organizations, such as ethernet/bus, ring, switched vs. routed",
                      "Identify the cross-layer interfaces needed for multimedia access and presentation, from image fetch from remote storage, through transport over a communications network, to staging into local memory, and final presentation to a graphical display",
                      "Describe the advantages and limitations of RAID architectures"
                  ]
              },
              {
                  "code": "AR/Functional Organization",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Implementation of simple datapaths, including instruction pipelining, hazard detection and resolution",
                      "Control unit: hardwired realization vs. microprogrammed realization"
                  ],
                  "hasTopicsCT2": [
                      "Instruction pipelining",
                      "Introduction to instruction-level parallelism (ILP)"
                  ],
                  "hasOutcomesCT1": [
                      "Compare alternative implementation of datapaths",
                      "Discuss the concept of control points and the generation of control signals using hardwired or microprogrammed implementations",
                      "Explain basic instruction level parallelism using pipelining and the major hazards that may occur"
                  ],
                  "hasOutcomesCT2": [
                      "Design and implement a complete processor, including datapath and control",
                      "Determine, for a given processor and memory system implementation, the average cycles per instruction"
                  ]
              },
              {
                  "code": "AR/Multiprocessing and Alternative Architectures",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Power Law",
                      "Example SIMD and MIMD instruction sets and architectures",
                      "Interconnection networks (hypercube, shuffle-exchange, mesh, crossbar)"
                  ],
                  "hasTopicsCT2": [
                      "Shared multiprocessor memory systems and memory consistency",
                      "Multiprocessor cache coherence"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the concept of parallel processing beyond the classical von Neumann model",
                      "Describe alternative parallel architectures such as SIMD and MIMD",
                      "Explain the concept of interconnection networks and characterize different approaches"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the special concerns that multiprocessing systems present with respect to memory management and describe how these are addressed",
                      "Describe the differences between memory backplane, processor memory interconnect, and remote memory via networks, their implications for access latency and impact on program performance"
                  ]
              },
              {
                  "code": "AR/Performance Enhancements",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Superscalar architecture",
                      "Branch prediction, Speculative execution, Out-of-order execution",
                      "Prefetching",
                      "Vector processors and GPUs"
                  ],
                  "hasTopicsCT2": [
                      "Hardware support for multithreading",
                      "Scalability",
                      "Alternative architectures, such as VLIW/EPIC, and Accelerators and other kinds of Special-Purpose Processors"
                  ],
                  "hasOutcomesCT1": [
                      "Describe superscalar architectures and their advantages",
                      "Explain the concept of branch prediction and its utility",
                      "Characterize the costs and benefits of prefetching"
                  ],
                  "hasOutcomesCT2": [
                      "Explain speculative execution and identify the conditions that justify it",
                      "Discuss the performance advantages that multithreading offered in an architecture along with the factors that make it difficult to derive maximum benefits from this approach",
                      "Describe the relevance of scalability to performance"
                  ]
              }
          ]
      },
      {
          "@id": "CN",
          "name": "Computational Science",
          "id": "CN",
          "hasChild": [
              {
                  "code": "CN/Introduction to Modeling and Simulation",
                  "tier1": "1",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Models as abstractions of situations",
                      "Simulations as dynamic modeling",
                      "Simulation techniques and tools, such as physical simulations, human-in-the-loop guided simulations, and virtual reality",
                      "Foundational approaches to validating models (e.g., comparing a simulation’s output to real data or the output of another model)",
                      "Presentation of results in a form relevant to the system being modeled"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a problem",
                      "Describe the relationship between modeling and simulation, i.e., thinking of simulation as dynamic modeling",
                      "Create a simple, formal mathematical model of a real-world situation and use that model in a simulation",
                      "Differentiate among the different types of simulations, including physical simulations, human-guided simulations, and virtual reality",
                      "Describe several approaches to validating models",
                      "Create a simple display of the results of a simulation"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "CN/Modeling and Simulation",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Purpose of modeling and simulation including optimization; supporting decision making, forecasting, safety considerations; for training and education",
                      "Tradeoffs including performance, accuracy, validity, and complexity",
                      "The simulation process; identification of key characteristics or behaviors, simplifying assumptions; validation of outcomes",
                      "Model building: use of mathematical formulas or equations, graphs, constraints; methodologies and techniques; use of time stepping for dynamic systems"
                  ],
                  "hasTopicsCT2": [
                      "Formal models and modeling techniques: mathematical descriptions involving simplifying assumptions and avoiding detail",
                      "Assessing and evaluating models and simulations in a variety of contexts; verification and validation of models and simulations",
                      "Important application areas including health care and diagnostics, economics and finance, city and urban planning, science, and engineering",
                      "Software in support of simulation and modeling; packages, languages"
                  ],
                  "hasOutcomesCT1": [
                      "Explain and give examples of the benefits of simulation and modeling in a range of important application areas",
                      "Demonstrate the ability to apply the techniques of modeling and simulation to a range of problem areas",
                      "Explain the constructs and concepts of a particular modeling approach",
                      "Explain the difference between validation and verification of a model; demonstrate the difference with specific examples",
                      "Verify and validate the results of a simulation"
                  ],
                  "hasOutcomesCT2": [
                      "Evaluate a simulation, highlighting the benefits and the drawbacks",
                      "Choose an appropriate modeling approach for a given problem or situation",
                      "Compare results from different simulations of the same situation and explain any differences",
                      "Infer the behavior of a system from the results of a simulation of the system",
                      "Extend or adapt an existing model to a new situation"
                  ]
              },
              {
                  "code": "CN/Processing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "The concept of an algorithm consisting of a finite number of well-defined steps, each of which completes in a finite amount of time, as does the entire process",
                      "Examples of well-known algorithms such as sorting and searching",
                      "The concept of analysis as understanding what the problem is really asking, how a problem can be approached using an algorithm, and how information is represented so that a machine can process it",
                      "The development or identification of a workflow",
                      "The process of converting an algorithm to machine-executable code",
                      "Software processes including lifecycle models, requirements, design, implementation, verification and maintenance",
                      "Machine representation of data computer arithmetic",
                      "Algorithms for numerically fitting data (e.g., Newton’s method)",
                      "Architectures for numerical computation, including parallel architectures",
                      "Bandwidth"
                  ],
                  "hasTopicsCT2": [
                      "Latency",
                      "Scalability",
                      "Granularity",
                      "Parallelism including task, data, and event parallelism",
                      "Parallel architectures including processor architectures, memory and caching",
                      "Parallel programming paradigms including threading, message passing, event driven techniques, parallel software architectures, and MapReduce",
                      "Grid computing",
                      "The impact of architecture on computational time",
                      "Total time to science curve for parallelism: continuum of things",
                      "Computing costs, e.g., the cost of re-computing a value vs. the cost of storing and lookup"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the characteristics and defining properties of algorithms and how they relate to machine processing",
                      "Analyze simple problem statements to identify relevant information and select appropriate processing to solve the problem",
                      "Identify or sketch a workflow for an existing computational process such as the creation of a graph based on experimental data",
                      "Describe the process of converting an algorithm to machine-executable code",
                      "Summarize the phases of software development and compare several common lifecycle models",
                      "Explain how data is represented in a machine. Compare representations of integers to floating point numbers. Describe underflow, overflow, round off, and truncation errors in data representations"
                  ],
                  "hasOutcomesCT2": [
                      "Apply standard numerical algorithms to solve ODEs and PDEs. Use computing systems to solve systems of equations",
                      "Describe the basic properties of bandwidth, latency, scalability and granularity",
                      "Describe the levels of parallelism including task, data, and event parallelism",
                      "Compare and contrast parallel programming paradigms recognizing the strengths and weaknesses of each",
                      "Identify the issues impacting correctness and efficiency of a computation",
                      "Design, code, test and debug programs for a parallel computation"
                  ]
              },
              {
                  "code": "CN/Interactive Visualization",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Principles of data visualization",
                      "Graphing and visualization algorithms"
                  ],
                  "hasTopicsCT2": [
                      "Image processing techniques",
                      "Scalability concerns"
                  ],
                  "hasOutcomesCT1": [
                      "Compare common computer interface mechanisms with respect to ease-of-use, learnability, and cost",
                      "Use standard APIs and tools to create visual displays of data, including graphs, charts, tables, and histograms",
                      "Describe several approaches to using a computer as a means for interacting with and processing data"
                  ],
                  "hasOutcomesCT2": [
                      "Extract useful information from a dataset",
                      "Analyze and select visualization techniques for specific problems",
                      "Describe issues related to scaling data analysis from small to large data sets"
                  ]
              },
              {
                  "code": "CN/Data, Information, and Knowledge",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Content management models, frameworks, systems, design methods (as in IM. Information Management)",
                      "Digital representations of content including numbers, text, images (e.g., raster and vector), video (e.g., QuickTime, MPEG2, MPEG4), audio (e.g., written score, MIDI, sampled digitized sound track) and animations; complex/composite/aggregate objects; FRBR",
                      "Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting",
                      "Content structure / management, including digital libraries and static/dynamic/stream aspects for data structures, databases",
                      "Content structure / management, including digital libraries and static/dynamic/stream aspects for document collections, multimedia pools, hyperbases (hypertext, hypermedia), catalogs, repositories"
                  ],
                  "hasTopicsCT2": [
                      "Content structure / management, including digital libraries and static/dynamic/stream aspects for ontologies, triple stores, semantic networks, rules",
                      "Processing and pattern recognition, including indexing, searching (including: queries and query languages; central / federated / P2P), retrieving, clustering, classifying/categorizing, analyzing/mining/extracting, rendering, reporting, handling transactions",
                      "User / society support for presentation and interaction, including browse, search, filter, route, visualize, share, collaborate, rate, annotate, personalize, recommend",
                      "Modeling, design, logical and physical implementation, using relevant systems/software"
                  ],
                  "hasOutcomesCT1": [
                      "Identify all of the data, information, and knowledge elements and related organizations, for a computational science application",
                      "Describe how to represent data and information for processing",
                      "Describe typical user requirements regarding that data, information, and knowledge",
                      "Select a suitable system or software implementation to manage data, information, and knowledge"
                  ],
                  "hasOutcomesCT2": [
                      "List and describe the reports, transactions, and other processing needed for a computational science application",
                      "Compare and contrast database management, information retrieval, and digital library systems with regard to handling typical computational science applications",
                      "Design a digital library for some computational science users/societies, with appropriate content and services"
                  ]
              },
              {
                  "code": "CN/Numerical Analysis",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Error, stability, convergence, including truncation and round-off",
                      "Function approximation including Taylor’s series, interpolation, extrapolation, and regression"
                  ],
                  "hasTopicsCT2": [
                      "Numerical differentiation and integration (Simpson’s Rule, explicit and implicit methods)",
                      "Differential equations (Euler’s Method, finite differences)"
                  ],
                  "hasOutcomesCT1": [
                      "Define error, stability, machine precision concepts and the inexactness of computational approximations",
                      "Implement Taylor series, interpolation, extrapolation, and regression algorithms for approximating functions"
                  ],
                  "hasOutcomesCT2": [
                      "Implement algorithms for differentiation and integration",
                      "Implement algorithms for solving differential equations"
                  ]
              }
          ]
      },
      {
          "@id": "DS",
          "name": "Discrete Structures",
          "id": "CN",
          "hasChild": [
              {
                  "code": "DS/Sets, Relations, and Functions",
                  "tier1": "4",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Set Venn diagrams",
                      "Set Union, intersection, complement",
                      "Set Cartesian product",
                      "Set Power sets",
                      "Set Cardinality of finite sets",
                      "Relation Reflexivity, symmetry, transitivity",
                      "Relation Equivalence relations, partial orders",
                      "Function Surjections, injections, bijections",
                      "Function Inverses",
                      "Function Composition"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Explain with examples the basic terminology of functions, relations, and sets",
                      "Perform the operations associated with sets, functions, and relations",
                      "Relate practical examples to the appropriate set, function, or relation model, and interpret the associated operations and terminology in context"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "DS/Basic Logic",
                  "tier1": "9",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Propositional logic",
                      "Logical connectives",
                      "Truth tables",
                      "Normal forms (conjunctive and disjunctive)",
                      "Validity of well-formed formula",
                      "Propositional inference rules (concepts of modus ponens and modus tollens)",
                      "Predicate logic universal and existential quantification",
                      "Limitations of propositional and predicate logic (e.g., expressiveness issues)"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Convert logical statements from informal language to propositional and predicate logic expressions",
                      "Apply formal methods of symbolic propositional and predicate logic, such as calculating validity of formulae and computing normal forms",
                      "Use the rules of inference to construct proofs in propositional and predicate logic",
                      "Describe how symbolic logic can be used to model real-life situations or applications, including those arising in computing contexts such as software analysis (e.g., program correctness), database queries, and algorithms",
                      "Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such as predicting the behavior of software or solving problems such as puzzles",
                      "Describe the strengths and limitations of propositional and predicate logic"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "DS/Proof Techniques",
                  "tier1": "10",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Notions of implication, equivalence, converse, inverse, contrapositive, negation, and contradiction",
                      "The structure of mathematical proofs",
                      "Direct proofs",
                      "Disproving by counterexample",
                      "Proof by contradiction",
                      "Induction over natural numbers",
                      "Structural induction",
                      "Weak and strong induction (i.e., First and Second Principle of Induction)",
                      "Recursive mathematical definitions"
                  ],
                  "hasTopicsCT2": [
                      "Well orderings"
                  ],
                  "hasOutcomesCT1": [
                      "Identify the proof technique used in a given proof",
                      "Outline the basic structure of each proof technique (direct proof, proof by contradiction, and induction) described in this unit",
                      "Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly in the construction of a sound argument",
                      "Determine which type of proof is best for a given problem",
                      "Explain the parallels between ideas of mathematical and/or structural induction to recursion and recursively defined structures",
                      "Explain the relationship between weak and strong induction and give examples of the appropriate use of each"
                  ],
                  "hasOutcomesCT2": [
                      "State the well-ordering principle and its relationship to mathematical induction"
                  ]
              },
              {
                  "code": "DS/Basics of Counting",
                  "tier1": "5",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Counting arguments",
                      "The pigeonhole principle",
                      "Permutations and combinations",
                      "Solving recurrence relations",
                      "Basic modular arithmetic"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Apply counting arguments, including sum and product rules, inclusion-exclusion principle and arithmetic/geometric progressions",
                      "Apply the pigeonhole principle in the context of a formal proof",
                      "Compute permutations and combinations of a set, and interpret the meaning in the context of the particular application",
                      "Map real-world applications to appropriate counting formalisms, such as determining the number of ways to arrange people around a table, subject to constraints on the seating arrangement, or the number of ways to determine certain hands in cards (e.g., a full house)",
                      "Solve a variety of basic recurrence relations",
                      "Analyze a problem to determine underlying recurrence relations",
                      "Perform computations involving modular arithmetic"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "DS/Graphs and Trees",
                  "tier1": "3",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Trees",
                      "Undirected graphs",
                      "Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting",
                      "Directed graphs",
                      "Weighted graphs"
                  ],
                  "hasTopicsCT2": [
                      "Spanning trees/forests",
                      "Graph isomorphism"
                  ],
                  "hasOutcomesCT1": [
                      "Illustrate by example the basic terminology of graph theory, as well as some of the properties and special cases of each type of graph/tree",
                      "Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order traversal of trees",
                      "Model a variety of real-world problems in computer science using appropriate forms of graphs and trees, such as representing a network topology or the organization of a hierarchical file system",
                      "Show how concepts from graphs and trees appear in data structures, algorithms, proof techniques (structural induction), and counting"
                  ],
                  "hasOutcomesCT2": [
                      "Explain how to construct a spanning tree of a graph",
                      "Determine if two graphs are isomorphic"
                  ]
              },
              {
                  "code": "DS/Discrete Probability",
                  "tier1": "6",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Finite probability space, events",
                      "Axioms of probability and probability measures",
                      "Conditional probability, Bayes’ theorem",
                      "Independence",
                      "Integer random variables (Bernoulli, binomial)",
                      "Expectation, including Linearity of Expectation"
                  ],
                  "hasTopicsCT2": [
                      "Variance",
                      "Conditional Independence"
                  ],
                  "hasOutcomesCT1": [
                      "Calculate probabilities of events and expectations of random variables for elementary problems such as games of chance",
                      "Differentiate between dependent and independent events",
                      "Identify a case of the binomial distribution and compute a probability using that distribution",
                      "Apply Bayes theorem to determine conditional probabilities in a problem",
                      "Apply the tools of probability to solve problems such as the average case analysis of algorithms or analyzing hashing"
                  ],
                  "hasOutcomesCT2": [
                      "Compute the variance for a given probability distribution",
                      "Explain how events that are independent can be conditionally dependent (and vice-versa). Identify real- world examples of such cases"
                  ]
              }
          ]
      },
      {
          "@id": "GV",
          "name": "Graphics and Visualization",
          "id": "GV",
          "hasChild": [
              {
                  "code": "GV/Fundamental Concepts",
                  "tier1": "2",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Media applications including user interfaces, audio and video editing, game engines, cad, visualization, virtual reality",
                      "Digitization of analog data, resolution, and the limits of human perception, e.g., pixels for visual display, dots for laser printers, and samples for audio (HCI/Foundations)",
                      "Use of standard APIs for the construction of UIs and display of standard media formats (see HCI/GUI construction)",
                      "Standard media formats, including lossless and lossy formats"
                  ],
                  "hasTopicsCT2": [
                      "Additive and subtractive color models (CMYK and RGB) and why these provide a range of colors",
                      "Tradeoffs between storing data and re-computing data as embodied by vector and raster representations of images",
                      "Animation as a sequence of still images"
                  ],
                  "hasOutcomesCT1": [
                      "Identify common uses of digital presentation to humans (e.g., computer graphics, sound)",
                      "Explain in general terms how analog signals can be reasonably represented by discrete samples, for example, how images can be represented by pixels",
                      "Explain how the limits of human perception affect choices about the digital representation of analog signals",
                      "Construct a simple user interface using a standard API",
                      "Describe the differences between lossy and lossless image compression techniques, for example as reflected in common graphics image file formats such as JPG, PNG, MP3, MP4, and GIF"
                  ],
                  "hasOutcomesCT2": [
                      "Describe color models and their use in graphics display devices",
                      "Describe the tradeoffs between storing information vs. storing enough information to reproduce the information, as in the difference between vector and raster rendering"
                  ]
              },
              {
                  "code": "GV/Basic Rendering",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Rendering in nature, e.g., the emission and scattering of light and its relation to numerical integration",
                      "Forward and backward rendering (i.e., ray-casting and rasterization)",
                      "Polygonal representation",
                      "Basic radiometry, similar triangles, and projection model",
                      "Affine and coordinate system transformations",
                      "Ray tracing",
                      "Visibility and occlusion, including solutions to this problem such as depth buffering, Painter’s algorithm, and ray tracing"
                  ],
                  "hasTopicsCT2": [
                      "The forward and backward rendering equation",
                      "Simple triangle rasterization",
                      "Rendering with a shader-based API",
                      "Texture mapping, including minification and magnification (e.g., trilinear MIP-mapping)",
                      "Application of spatial data structures to rendering",
                      "Sampling and anti-aliasing",
                      "Scene graphs and the graphics pipeline"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the light transport problem and its relation to numerical integration i.e., light is emitted, scatters around the scene, and is measured by the eye",
                      "Describe the basic graphics pipeline and how forward and backward rendering factor in this",
                      "Create a program to display 3D models of simple graphics images",
                      "Derive linear perspective from similar triangles by converting points (x, y, z) to points (x/z, y/z, 1)",
                      "Obtain 2-dimensional and 3-dimensional points by applying affine transformations",
                      "Apply 3-dimensional coordinate system and the changes required to extend 2D transformation operations to handle transformations in 3D",
                      "Contrast forward and backward rendering"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the concept and applications of texture mapping, sampling, and anti-aliasing",
                      "Explain the ray tracing/rasterization duality for the visibility problem",
                      "Implement simple procedures that perform transformation and clipping operations on simple 2-dimensional images",
                      "Implement a simple real-time renderer using a rasterization API (e.g., OpenGL) using vertex buffers and shaders",
                      "Compare and contrast the different rendering techniques",
                      "Compute space requirements based on resolution and color coding",
                      "Compute time requirements based on refresh rates, rasterization techniques."
                  ]
              },
              {
                  "code": "GV/Geometric Modeling",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Basic geometric operations such as intersection calculation and proximity tests",
                      "Volumes, voxels, and point-based representations",
                      "Parametric polynomial curves and surfaces",
                      "Implicit representation of curves and surfaces",
                      "Approximation techniques such as polynomial curves, Bezier curves, spline curves and surfaces, and non-uniform rational basis (NURB) spines, and level set method",
                      "Surface representation techniques including tessellation, mesh representation, mesh fairing, and mesh generation techniques such as Delaunay triangulation, marching cubes",
                      "Spatial subdivision techniques"
                  ],
                  "hasTopicsCT2": [
                      "Procedural models such as fractals, generative modeling, and L-systems",
                      "Graftals, cross referenced with programming languages (grammars to generated pictures)",
                      "Elastically deformable and freeform deformable models",
                      "Subdivision surfaces",
                      "Multiresolution modeling",
                      "Reconstruction",
                      "Constructive Solid Geometry (CSG) representation"
                  ],
                  "hasOutcomesCT1": [
                      "Represent curves and surfaces using both implicit and parametric forms",
                      "Create simple polyhedral models by surface tessellation",
                      "Generate a mesh representation from an implicit surface",
                      "Generate a fractal model or terrain using a procedural method"
                  ],
                  "hasOutcomesCT2": [
                      "Generate a mesh from data points acquired with a laser scanner",
                      "Construct CSG models from simple primitives, such as cubes and quadric surfaces",
                      "Contrast modeling approaches with respect to space and time complexity and quality of image"
                  ]
              },
              {
                  "code": "GV/Advanced Rendering",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Solutions and approximations to the rendering equation",
                      "Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on rendering",
                      "Shadow mapping",
                      "Occlusion culling",
                      "Bidirectional Scattering Distribution function (BSDF) theory and microfacets",
                      "Subsurface scattering"
                  ],
                  "hasTopicsCT2": [
                      "Area light sources",
                      "Hierarchical depth buffering",
                      "The Light Field, image-based rendering",
                      "Non-photorealistic rendering",
                      "GPU architecture",
                      "Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion"
                  ],
                  "hasOutcomesCT1": [
                      "Demonstrate how an algorithm estimates a solution to the rendering equation",
                      "Prove the properties of a rendering algorithm, e.g., complete, consistent, and unbiased",
                      "Analyze the bandwidth and computation demands of a simple algorithm",
                      "Implement a non-trivial shading algorithm (e.g., toon shading, cascaded shadow maps) under a rasterization API"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss how a particular artistic technique might be implemented in a renderer",
                      "Explain how to recognize the graphics techniques used to create a particular image",
                      "Implement any of the specified graphics techniques using a primitive graphics system at the individual pixel level",
                      "Implement a ray tracer for scenes using a simple (e.g., Phong model) BRDF plus reflection and refraction"
                  ]
              },
              {
                  "code": "GV/Computer Animation",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Forward and inverse kinematics",
                      "Collision detection and response",
                      "Procedural animation using noise, rules (boids/crowds), and particle systems",
                      "Skinning algorithms",
                      "Physics based motions including rigid body dynamics, physical particle systems, mass-spring networks for cloth and flesh and hair"
                  ],
                  "hasTopicsCT2": [
                      "Key-frame animation",
                      "Splines",
                      "Data structures for rotations, such as quaternions",
                      "Camera animation",
                      "Motion capture"
                  ],
                  "hasOutcomesCT1": [
                      "Compute the location and orientation of model parts using a forward kinematic approach",
                      "Compute the orientation of articulated parts of a model from a location and orientation using an inverse kinematic approach",
                      "Describe the tradeoffs in different representations of rotations",
                      "Implement the spline interpolation method for producing in-between positions and orientations"
                  ],
                  "hasOutcomesCT2": [
                      "Implement algorithms for physical modeling of particle dynamics using simple Newtonian mechanics, for example Witkin & Kass, snakes and worms, symplectic Euler, Stormer/Verlet, or midpoint Euler methods",
                      "Discuss the basic ideas behind some methods for fluid dynamics for modeling ballistic trajectories, for example for splashes, dust, fire, or smoke",
                      "Use common animation software to construct simple organic forms using metaball and skeleton"
                  ]
              },
              {
                  "code": "GV/Visualization",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Visualization of 2D/3D scalar fields: color mapping, isosurfaces",
                      "Direct volume data rendering: ray-casting, transfer functions, segmentation",
                      "Visualization of vector fields and flow data",
                      "Visualization of time-varying data",
                      "Visualization of high-dimensional data: dimension reduction, parallel coordinates"
                  ],
                  "hasTopicsCT2": [
                      "Visualization of non-spatial data: multi-variate, tree/graph structured, text",
                      "Perceptual and cognitive foundations that drive visual abstractions",
                      "Visualization design",
                      "Evaluation of visualization methods",
                      "Applications of visualization"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the basic algorithms for scalar and vector visualization",
                      "Describe the tradeoffs of visualization algorithms in terms of accuracy and performance",
                      "Propose a suitable visualization design for a particular combination of data characteristics and application tasks"
                  ],
                  "hasOutcomesCT2": [
                      "Analyze the effectiveness of a given visualization for a particular task",
                      "Design a process to evaluate the utility of a visualization algorithm or system",
                      "Recognize a variety of applications of visualization including representations of scientific, medical, and mathematical data; flow visualization; and spatial analysis"
                  ]
              }
          ]
      },
      {
          "@id": "HCI",
          "name": "Human Computer Interaction",
          "id": "HCI",
          "hasChild": [
              {
                  "code": "HCI/Foundations",
                  "tier1": "4",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Contexts for HCI (anything with a user interface, e.g., webpage, business applications, mobile applications, and games)",
                      "Processes for user-centered development, e.g., early focus on users, empirical testing, iterative design",
                      "Different measures for evaluation, e.g., utility, efficiency, learnability, user satisfaction",
                      "Usability heuristics and the principles of usability testing",
                      "Physical capabilities that inform interaction design, e.g., color perception, ergonomics",
                      "Cognitive models that inform interaction design, e.g., attention, perception and recognition, movement, and memory; gulfs of expectation and execution",
                      "Social models that inform interaction design, e.g., culture, communication, networks and organizations",
                      "Principles of good design and good designers; engineering tradeoffs",
                      "Accessibility, e.g., interfaces for differently-abled populations (e.g., blind, motion-impaired)",
                      "Interfaces for differently-aged population groups (e.g., children, 80+)"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Discuss why human-centered software development is important",
                      "Summarize the basic precepts of psychological and social interaction",
                      "Develop and use a conceptual vocabulary for analyzing human interaction with software: affordance, conceptual model, feedback, and so forth",
                      "Define a user-centered design process that explicitly takes account of the fact that the user is not like the developer or their acquaintances",
                      "Create and conduct a simple usability test for an existing software application"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "HCI/Designing Interaction",
                  "tier1": "0",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Principles of graphical user interfaces (GUIs)",
                      "Elements of visual design (layout, color, fonts, labeling)",
                      "Task analysis, including qualitative aspects of generating task analytic models",
                      "Low-fidelity (paper) prototyping",
                      "Quantitative evaluation techniques, e.g., keystroke-level evaluation",
                      "Help and documentation",
                      "Handling human/system failure",
                      "User interface standards"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "For an identified user group, undertake and document an analysis of their needs",
                      "Create a simple application, together with help and documentation, that supports a graphical user interface",
                      "Conduct a quantitative evaluation and discuss/report the results",
                      "Discuss at least one national or international user interface design standard"
                  ]
              },
              {
                  "code": "HCI/Programming Interactive Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Software Architecture Patterns, e.g., Model-View controller; command objects, online, offline",
                      "Interaction Design Patterns: visual hierarchy, navigational distance",
                      "Event management and user interaction",
                      "Geometry management",
                      "Choosing interaction styles and interaction techniques",
                      "Presenting information: navigation, representation, manipulation",
                      "Interface animation techniques (e.g., scene graphs)"
                  ],
                  "hasTopicsCT2": [
                      "Widget classes and libraries",
                      "Modern GUI libraries (e.g. iOS, Android, JavaFX) GUI builders and UI programming environments",
                      "Declarative Interface Specification: Stylesheets and DOMs",
                      "Data-driven applications (database-backed web pages)",
                      "Cross-platform design",
                      "Design for resource-constrained devices (e.g. small, mobile devices)"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the importance of Model-View controller to interface programming",
                      "Create an application with a modern graphical user interface"
                  ],
                  "hasOutcomesCT2": [
                      "Identify commonalities and differences in UIs across different platforms",
                      "Explain and use GUI programming concepts: event handling, constraint-based layout management, etc"
                  ]
              },
              {
                  "code": "HCI/User-Centered Design and Testing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Approaches to, and characteristics of, the design process",
                      "Functionality and usability requirements",
                      "Techniques for gathering requirements, e.g., interviews, surveys, ethnographic and contextual enquiry",
                      "Techniques and tools for the analysis and presentation of requirements, e.g., reports, personas",
                      "Prototyping techniques and tools, e.g., sketching, storyboards, low-fidelity prototyping, wireframes"
                  ],
                  "hasTopicsCT2": [
                      "Evaluation without users, using both qualitative and quantitative techniques, e.g., walkthroughs, GOMS, expert-based analysis, heuristics, guidelines, and standards",
                      "Evaluation with users, e.g., observation, think-aloud, interview, survey, experiment",
                      "Challenges to effective evaluation, e.g., sampling, generalization",
                      "Reporting the results of evaluations",
                      "Internationalization, designing for users from other cultures, cross-cultural"
                  ],
                  "hasOutcomesCT1": [
                      "Explain how user-centered design complements other software process models",
                      "Use lo-fi (low fidelity) prototyping techniques to gather, and report, user responses",
                      "Choose appropriate methods to support the development of a specific UI"
                  ],
                  "hasOutcomesCT2": [
                      "Use a variety of techniques to evaluate a given UI",
                      "Compare the constraints and benefits of different evaluative methods"
                  ]
              },
              {
                  "code": "HCI/New Interactive Technologies",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Choosing interaction styles and interaction techniques",
                      "Representing information to users: navigation, representation, manipulation"
                  ],
                  "hasTopicsCT2": [
                      "Approaches to design, implementation and evaluation of non-mouse interaction"
                  ],
                  "hasOutcomesCT1": [
                      "Describe when non-mouse interfaces are appropriate",
                      "Understand the interaction possibilities beyond mouse-and-pointer interfaces"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the advantages (and disadvantages) of non-mouse interfaces"
                  ]
              },
              {
                  "code": "HCI/Collaboration and Communication",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Asynchronous group communication, e.g., e-mail, forums, social networks",
                      "Synchronous group communication, e.g., chat rooms, conferencing, online games",
                      "Social media, social computing, and social network analysis",
                      "Online collaboration, smart spaces, and social coordination aspects of workflow technologies"
                  ],
                  "hasTopicsCT2": [
                      "Online communities",
                      "Software characters and intelligent agents, virtual worlds and avatars",
                      "Social psychology"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the difference between synchronous and asynchronous communication",
                      "Compare the HCI issues in individual interaction with group interaction"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss several issues of social concern raised by collaborative software",
                      "Discuss the HCI issues in software that embodies human intention"
                  ]
              },
              {
                  "code": "HCI/Statistical Methods for HCI",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "t-tests",
                      "ANOVA",
                      "Randomization (non-parametric) testing, within vs. between-subjects design",
                      "Calculating effect size"
                  ],
                  "hasTopicsCT2": [
                      "Exploratory data analysis",
                      "Presenting statistical data",
                      "Combining qualitative and quantitative results"
                  ],
                  "hasOutcomesCT1": [
                      "Explain basic statistical concepts and their areas of application",
                      "Extract and articulate the statistical arguments used in papers that quantitatively report user studies"
                  ],
                  "hasOutcomesCT2": [
                      "Design a user study that will yield quantitative results",
                      "Conduct and report on a study that utilizes both qualitative and quantitative evaluation"
                  ]
              },
              {
                  "code": "HCI/Human Factors and Security",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Applied psychology and security policies",
                      "Security economics",
                      "Regulatory environments – responsibility, liability and self-determination",
                      "Organizational vulnerabilities and threats",
                      "Usability design and security"
                  ],
                  "hasTopicsCT2": [
                      "Pretext, impersonation and fraud, e.g., phishing and spear phishing",
                      "Trust, privacy and deception",
                      "Biometric authentication (camera, voice)",
                      "Identity management"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the concepts of phishing and spear phishing, and how to recognize them",
                      "Describe the issues of trust in interface design with an example of a high and low trust system",
                      "Design a user interface for a security mechanism"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the concept of identity management and its importance",
                      "Analyze a security policy and/or procedures to show where they consider, or fail to consider, human factors"
                  ]
              },
              {
                  "code": "HCI/Design-Oriented HCI",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Intellectual styles and perspectives to technology and its interfaces",
                      "Consideration of HCI as a design discipline"
                  ],
                  "hasTopicsCT2": [
                      "Critically reflective HCI",
                      "Indicative domains of application"
                  ],
                  "hasOutcomesCT1": [
                      "Explain what is meant by HCI is a design-oriented discipline",
                      "Detail the processes of design appropriate to specific design orientations"
                  ],
                  "hasOutcomesCT2": [
                      "Apply a variety of design methods to a given problem"
                  ]
              },
              {
                  "code": "HCI/Mixed, Augmented and Virtual Reality",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Output sound",
                      "Output stereoscopic display",
                      "Output force feedback simulation, haptic devices",
                      "User input viewer and object tracking",
                      "User input pose and gesture recognition",
                      "User input accelerometers"
                  ],
                  "hasTopicsCT2": [
                      "User input fiducial markers",
                      "User input user interface issues",
                      "Physical modelling and rendering",
                      "System architectures",
                      "Networking p2p, client-server, dead reckoning, encryption, synchronization",
                      "Networking distributed collaboration"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the optical model realized by a computer graphics system to synthesize stereoscopic view",
                      "Describe the principles of different viewer tracking technologies",
                      "Describe the differences between geometry- and image-based virtual reality"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the issues of user action synchronization and data consistency in a networked environment",
                      "Determine the basic requirements on interface, hardware, and software configurations of a VR system for a specified application",
                      "Describe several possible uses for games engines, including their potential and their limitations"
                  ]
              }
          ]
      },
      {
          "@id": "IAS",
          "name": "Information Assurance and Security",
          "id": "IAS",
          "hasChild": [
              {
                  "code": "IAS/Foundational Concepts in Security",
                  "tier1": "1",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "CIA (Confidentiality, Integrity, Availability)",
                      "Concepts of risk, threats, vulnerabilities, and attack vectors",
                      "Authentication and authorization, access control (mandatory vs. discretionary)",
                      "Concept of trust and trustworthiness",
                      "Ethics (responsible disclosure)"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Analyze the tradeoffs of balancing key security properties (Confidentiality, Integrity, and Availability)",
                      "Describe the concepts of risk, threats, vulnerabilities and attack vectors (including the fact that there is no such thing as perfect security)",
                      "Explain the concepts of authentication, authorization, access control",
                      "Explain the concept of trust and trustworthiness",
                      "Describe important ethical issues to consider in computer security, including ethical issues associated with fixing or not fixing vulnerabilities and disclosing or not disclosing vulnerabilities"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "IAS/Principles of Secure Design",
                  "tier1": "1",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Least privilege and isolation",
                      "Fail-safe defaults",
                      "Open design",
                      "End-to-end security",
                      "Defense in depth (e.g., defensive programming, layered defense)",
                      "Security by design",
                      "Tensions between security and other design goals"
                  ],
                  "hasTopicsCT2": [
                      "Complete mediation",
                      "Use of vetted security components",
                      "Economy of mechanism (reducing trusted computing base, minimize attack surface)",
                      "Usable security",
                      "Security composability",
                      "Prevention, detection, and deterrence"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the principle of least privilege and isolation as applied to system design",
                      "Summarize the principle of fail-safe and deny-by-default",
                      "Discuss the implications of relying on open design or the secrecy of design for security",
                      "Explain the goals of end-to-end data security",
                      "Discuss the benefits of having multiple layers of defenses",
                      "For each stage in the lifecycle of a product, describe what security considerations should be evaluated",
                      "Describe the cost and tradeoffs associated with designing security into a product"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the concept of mediation and the principle of complete mediation",
                      "Describe standard components for security operations, and explain the benefits of their use instead of re-inventing fundamentals operations",
                      "Explain the concept of trusted computing including trusted computing base and attack surface and the principle of minimizing trusted computing base",
                      "Discuss the importance of usability in security mechanism design",
                      "Describe security issues that arise at boundaries between multiple components",
                      "Identify the different roles of prevention mechanisms and detection/deterrence mechanisms"
                  ]
              },
              {
                  "code": "IAS/Defensive Programming",
                  "tier1": "1",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Input validation and data sanitization",
                      "Choice of programming language and type-safe languages",
                      "Examples of input validation and data sanitization errors such as Buffer overflows, Integer errors, SQL injection, XSS vulnerability",
                      "Race conditions",
                      "Correct handling of exceptions and unexpected behaviors"
                  ],
                  "hasTopicsCT2": [
                      "Correct usage of third-party components",
                      "Effectively deploying security updates"
                  ],
                  "hasOutcomesCT1": [
                      "Explain why input validation and data sanitization is necessary in the face of adversarial control of the input channel",
                      "Explain why you might choose to develop a program in a type-safe language like Java, in contrast to an unsafe programming language like C/C++",
                      "Classify common input validation errors, and write correct input validation code",
                      "Demonstrate using a high-level programming language how to prevent a race condition from occurring and how to handle an exception",
                      "Demonstrate the identification and graceful handling of error conditions"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the risks with misusing interfaces with third-party code and how to correctly use third-party code",
                      "Discuss the need to update software to fix security vulnerabilities and the lifecycle management of the fix"
                  ]
              },
              {
                  "code": "IAS/Threats and Attacks",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Attacker goals, capabilities, and motivations (such as underground economy, digital espionage, cyberwarfare, insider threats, hacktivism, advanced persistent threats)",
                      "Examples of malware (e.g., viruses, worms, spyware, botnets, Trojan horses or rootkits)",
                      "Denial of Service (DoS) and Distributed Denial of Service (DDoS)",
                      "Social engineering (e.g., phishing)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe likely attacker types against a particular system",
                      "Discuss the limitations of malware countermeasures (e.g., signature-based detection, behavioral detection)",
                      "Identify instances of social engineering attacks and Denial of Service attacks",
                      "Discuss how Denial of Service attacks can be identified and mitigated"
                  ]
              },
              {
                  "code": "IAS/Network Security",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic redirection, man-in-the-middle, message integrity attacks, routing attacks, and traffic analysis)",
                      "Use of cryptography for data and network security",
                      "Architectures for secure networks (e.g., secure channels, secure routing protocols, secure DNS, VPNs, anonymous communication protocols, isolation)",
                      "Defense mechanisms and countermeasures (e.g., network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots, tracebacks)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the different categories of network threats and attacks",
                      "Describe the architecture for public and private key cryptography and how public key infrastructure (PKI) supports network security",
                      "Describe virtues and limitations of security technologies at each layer of the network stack",
                      "Identify the appropriate defense mechanism(s) and its limitations given a network threat"
                  ]
              },
              {
                  "code": "IAS/Cryptography",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Basic Cryptography Terminology covering notions pertaining to the different (communication) partners, secure/unsecure channel, attackers and their capabilities, encryption, decryption, keys and their characteristics, signatures",
                      "Cipher types (e.g., Caesar cipher, affine cipher) together with typical attack methods such as frequency analysis",
                      "Public Key Infrastructure support for digital signature and encryption and its challenges"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the purpose of cryptography and list ways it is used in data communications",
                      "Define the following terms: cipher, cryptanalysis, cryptographic algorithm, and cryptology, and describe the two basic methods (ciphers) for transforming plain text in cipher text",
                      "Discuss the importance of prime numbers in cryptography and explain their use in cryptographic algorithms",
                      "Explain how public key infrastructure supports digital signing and encryption and discuss the limitations/vulnerabilities"
                  ]
              },
              {
                  "code": "IAS/Web Security",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Web security model",
                      "Session management, authentication",
                      "Application vulnerabilities and defenses"
                  ],
                  "hasTopicsCT2": [
                      "Client-side security",
                      "Server-side security tools, e.g. Web Application Firewalls (WAFs) and fuzzers"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the browser security model including same-origin policy and threat models in web security",
                      "Discuss the concept of web sessions, secure communication channels such as TLS and importance of secure certificates, authentication including single sign-on such as OAuth and SAML"
                  ],
                  "hasOutcomesCT2": [
                      "Describe common types of vulnerabilities and attacks in web applications, and defenses against them",
                      "Use client-side security capabilities in an application"
                  ]
              },
              {
                  "code": "IAS/Platform Security",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Code integrity and code signing",
                      "Secure boot, measured boot, and root of trust",
                      "Attestation",
                      "TPM and secure co-processors"
                  ],
                  "hasTopicsCT2": [
                      "Security threats from peripherals, e.g., DMA, IOMMU",
                      "Physical attacks: hardware Trojans, memory probes, cold boot attacks",
                      "Security of embedded devices, e.g., medical devices, cars",
                      "Trusted path"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the concept of code integrity and code signing and the scope it applies to",
                      "Discuss the concept of root of trust and the process of secure boot and secure loading",
                      "Describe the mechanism of remote attestation of system integrity",
                      "Summarize the goals and key primitives of TPM"
                  ],
                  "hasOutcomesCT2": [
                      "Identify the threats of plugging peripherals into a device",
                      "Identify physical attacks and countermeasures",
                      "Identify attacks on non-PC hardware platforms",
                      "Discuss the concept and importance of trusted path"
                  ]
              },
              {
                  "code": "IAS/Security Policy and Governance",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Privacy policy",
                      "Inference controls/statistical disclosure limitation",
                      "Backup policy, password refresh policy",
                      "Breach disclosure policy"
                  ],
                  "hasTopicsCT2": [
                      "Data collection and retention policies",
                      "Supply chain policy",
                      "Cloud security tradeoffs"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the concept of privacy including personally private information, potential violations of privacy due to security mechanisms, and describe how privacy protection mechanisms run in conflict with security mechanisms",
                      "Describe how an attacker can infer a secret by interacting with a database",
                      "Explain how to set a data backup policy or password refresh policy",
                      "Discuss how to set a breach disclosure policy"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the consequences of data retention policies",
                      "Identify the risks of relying on outsourced manufacturing",
                      "Identify the risks and benefits of outsourcing to the cloud"
                  ]
              },
              {
                  "code": "IAS/Digital Forensics",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Basic Principles and methodologies for digital forensics",
                      "Design systems with forensic needs in mind",
                      "Rules of Evidence – general concepts and differences between jurisdictions and Chain of Custody",
                      "Search and Seizure of evidence: legal and procedural requirements",
                      "Digital Evidence methods and standards",
                      "Techniques and standards for Preservation of Data",
                      "Legal and Reporting Issues including working as an expert witness",
                      "OS/File System Forensics"
                  ],
                  "hasTopicsCT2": [
                      "Application Forensics",
                      "Web Forensics",
                      "Network Forensics",
                      "Mobile Device Forensics",
                      "Computer/network/system attacks",
                      "Attack detection and investigation",
                      "Anti-forensics"
                  ],
                  "hasOutcomesCT1": [
                      "Describe what a digital investigation is, the sources of digital evidence, and the limitations of forensics",
                      "Explain how to design software to support forensics",
                      "Describe the legal requirements for use of seized data",
                      "Describe the process of evidence seizure from the time when the requirement was identified to the disposition of the data",
                      "Describe how data collection is accomplished and the proper storage of the original and forensics copy",
                      "Conduct data collection on a hard drive",
                      "Describe a person’s responsibility and liability while testifying as a forensics examiner",
                      "Recover data based on a given search term from an imaged system"
                  ],
                  "hasOutcomesCT2": [
                      "Reconstruct application history from application artifacts",
                      "Reconstruct web browsing history from web artifacts",
                      "Capture and interpret network traffic",
                      "Discuss the challenges associated with mobile device forensics",
                      "Inspect a system (network, computer, or application) for the presence of malware or malicious activity",
                      "Apply forensics tools to investigate security breaches",
                      "Identify anti-forensic methods"
                  ]
              },
              {
                  "code": "IAS/Secure Software Engineering",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Building security into the software development lifecycle",
                      "Secure design principles and patterns",
                      "Secure software specifications and requirements"
                  ],
                  "hasTopicsCT2": [
                      "Secure software development practices",
                      "Secure testing - the process of testing that security requirements are met (including static and dynamic analysis).",
                      "Software quality assurance and benchmarking measurements"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the requirements for integrating security into the software development lifecycle",
                      "Apply the concepts of the Design Principles for Protection Mechanisms, the Principles for Software Security [2], and the Principles for Secure Design [1] on a software development project",
                      "Develop specifications for a software development effort that fully specify functional requirements and identifies the expected execution paths"
                  ],
                  "hasOutcomesCT2": [
                      "Describe software development best practices for minimizing vulnerabilities in programming code",
                      "Conduct a security verification and assessment (static and dynamic) of a software application"
                  ]
              }
          ]
      },
      {
          "@id": "IM",
          "name": "Information Management",
          "id": "IM",
          "hasChild": [
              {
                  "code": "IM/Information Management Concepts",
                  "tier1": "1",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Information systems as socio-technical systems",
                      "Basic information storage and retrieval (IS&R) concepts",
                      "Information capture and representation",
                      "Supporting human needs: searching, retrieving, linking, browsing, navigating"
                  ],
                  "hasTopicsCT2": [
                      "Information management applications",
                      "Declarative and navigational queries, use of links",
                      "Analysis and indexing",
                      "Quality issues: reliability, scalability, efficiency, and effectiveness"
                  ],
                  "hasOutcomesCT1": [
                      "Describe how humans gain access to information and data to support their needs",
                      "Describe the advantages and disadvantages of central organizational control over data",
                      "Identify the careers/roles associated with information management (e.g., database administrator, data modeler, application developer, end-user)",
                      "Compare and contrast information with data and knowledge",
                      "Demonstrate uses of explicitly stored metadata/schema associated with data",
                      "Identify issues of data persistence for an organization"
                  ],
                  "hasOutcomesCT2": [
                      "Critique an information application with regard to satisfying user information needs",
                      "Explain uses of declarative queries",
                      "Give a declarative version for a navigational query",
                      "Describe several technical solutions to the problems related to information privacy, integrity, security, and preservation",
                      "Explain measures of efficiency (throughput, response time) and effectiveness (recall, precision)",
                      "Describe approaches to scale up information systems",
                      "Identify vulnerabilities and failure scenarios in common forms of information systems"
                  ]
              },
              {
                  "code": "IM/Database Systems",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Approaches to and evolution of database systems",
                      "Components of database systems",
                      "Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer management, access methods",
                      "Database architecture and data independence",
                      "Use of a declarative query language",
                      "Systems supporting structured and/or stream content"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain the characteristics that distinguish the database approach from the approach of programming with data files",
                      "Describe the most common designs for core database system components including the query optimizer, query executor, storage manager, access methods, and transaction processor",
                      "Cite the basic goals, functions, and models of database systems",
                      "Describe the components of a database system and give examples of their use",
                      "Identify major DBMS functions and describe their role in a database system",
                      "Explain the concept of data independence and its importance in a database system",
                      "Use a declarative query language to elicit information from a database",
                      "Describe facilities that datatbases provide supporting structures and/or stream (sequence) data, e.g., text"
                  ]
              },
              {
                  "code": "IM/Data Modeling",
                  "tier1": "0",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Data modeling",
                      "Conceptual models (e.g., entity-relationship, UML diagrams)",
                      "Spreadsheet models",
                      "Relational data models",
                      "Object-oriented models",
                      "Semi-structured data model (expressed using DTD or XML Schema, for example)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Compare and contrast appropriate data models, including internal structures, for different types of data",
                      "Describe concepts in modeling notation (e.g., Entity-Relation Diagrams or UML) and how they would be used",
                      "Define the fundamental terminology used in the relational data model",
                      "Describe the basic principles of the relational data model",
                      "Apply the modeling concepts and notation of the relational data model",
                      "Describe the main concepts of the OO model such as object identity, type constructors, encapsulation, inheritance, polymorphism, and versioning",
                      "Describe the differences between relational and semi-structured data models",
                      "Give a semi-structured equivalent (e.g., in DTD or XML Schema) for a given relational schema"
                  ]
              },
              {
                  "code": "IM/Indexing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "The impact of indices on query performance",
                      "The basic structure of an index",
                      "Keeping a buffer of data in memory"
                  ],
                  "hasTopicsCT2": [
                      "Creating indexes with SQL",
                      "Indexing text",
                      "Indexing the web (e.g., web crawling)"
                  ],
                  "hasOutcomesCT1": [
                      "Generate an index file for a collection of resources",
                      "Explain the role of an inverted index in locating a document in a collection",
                      "Explain how stemming and stop words affect indexing"
                  ],
                  "hasOutcomesCT2": [
                      "Identify appropriate indices for given relational schema and query set",
                      "Estimate time to retrieve information, when indices are used compared to when they are not used",
                      "Describe key challenges in web crawling, e.g., detecting duplicate documents, determining the crawling frontier"
                  ]
              },
              {
                  "code": "IM/Relational Databases",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Mapping conceptual schema to a relational schema",
                      "Entity and referential integrity",
                      "Relational algebra and relational calculus",
                      "Relational Database design",
                      "Functional dependency",
                      "Decomposition of a schema; lossless-join and dependency-preservation properties of a decomposition"
                  ],
                  "hasTopicsCT2": [
                      "Candidate keys, superkeys, and closure of a set of attributes",
                      "Normal forms (BCNF)",
                      "Multi-valued dependency (4NF)",
                      "Join dependency (PJNF, 5NF)",
                      "Representation theory"
                  ],
                  "hasOutcomesCT1": [
                      "Prepare a relational schema from a conceptual model developed using the entity- relationship model",
                      "Explain and demonstrate the concepts of entity integrity constraint and referential integrity constraint (including definition of the concept of a foreign key)",
                      "Demonstrate use of the relational algebra operations from mathematical set theory (union, intersection, difference, and Cartesian product) and the relational algebra operations developed specifically for relational databases (select (restrict), project, join, and division)",
                      "Write queries in the relational algebra",
                      "Write queries in the tuple relational calculus",
                      "Determine the functional dependency between two or more attributes that are a subset of a relation",
                      "Connect constraints expressed as primary key and foreign key, with functional dependencies"
                  ],
                  "hasOutcomesCT2": [
                      "Compute the closure of a set of attributes under given functional dependencies",
                      "Determine whether a set of attributes form a superkey and/or candidate key for a relation with given functional dependencies",
                      "Evaluate a proposed decomposition, to say whether it has lossless-join and dependency-preservation",
                      "Describe the properties of BCNF, PJNF, 5NF",
                      "Explain the impact of normalization on the efficiency of database operations especially query optimization",
                      "Describe what is a multi-valued dependency and what type of constraints it specifies"
                  ]
              },
              {
                  "code": "IM/Query Languages",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Overview of database languages",
                      "SQL (data definition, query formulation, update sublanguage, constraints, integrity)",
                      "Selections",
                      "Projections",
                      "Select-project-join",
                      "Aggregates and group-by"
                  ],
                  "hasTopicsCT2": [
                      "Subqueries",
                      "QBE and 4th-generation environments",
                      "Different ways to invoke non-procedural queries in conventional languages",
                      "Introduction to other major query languages (e.g., XPATH, SPARQL)",
                      "Stored procedures"
                  ],
                  "hasOutcomesCT1": [
                      "Create a relational database schema in SQL that incorporates key, entity integrity, and referential integrity constraints",
                      "Use SQL to create tables and retrieve (SELECT) information from a database",
                      "Evaluate a set of query processing strategies and select the optimal strategy"
                  ],
                  "hasOutcomesCT2": [
                      "Create a non-procedural query by filling in templates of relations to construct an example of the desired query result",
                      "Embed object-oriented queries into a stand-alone language such as C++ or Java",
                      "Write a stored procedure that deals with parameters and has some control flow, to provide a given functionality"
                  ]
              },
              {
                  "code": "IM/Transaction Processing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Transactions",
                      "Failure and recovery"
                  ],
                  "hasTopicsCT2": [
                      "Concurrency control",
                      "Interaction of transaction management with storage, especially buffering"
                  ],
                  "hasOutcomesCT1": [
                      "Create a transaction by embedding SQL into an application program",
                      "Explain the concept of implicit commits",
                      "Describe the issues specific to efficient transaction execution",
                      "Explain when and why rollback is needed and how logging assures proper rollback"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the effect of different isolation levels on the concurrency control mechanisms",
                      "Choose the proper isolation level for implementing a specified transaction protocol",
                      "Identify appropriate transaction boundaries in application programs"
                  ]
              },
              {
                  "code": "IM/Distributed Databases",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Distributed DBMS"
                  ],
                  "hasTopicsCT2": [
                      "Parallel DBMS"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the techniques used for data fragmentation, replication, and allocation during the distributed database design process",
                      "Evaluate simple strategies for executing a distributed query to select the strategy that minimizes the amount of data transfer",
                      "Explain how the two-phase commit protocol is used to deal with committing a transaction that accesses databases stored on multiple nodes"
                  ],
                  "hasOutcomesCT2": [
                      "Describe distributed concurrency control based on the distinguished copy techniques and the voting method",
                      "Describe the three levels of software in the client-server model"
                  ]
              },
              {
                  "code": "IM/Physical Database Design",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Storage and file structure",
                      "Indexed files",
                      "Hashed files",
                      "Signature files"
                  ],
                  "hasTopicsCT2": [
                      "B-trees",
                      "Files with dense index",
                      "Files with variable length records",
                      "Database efficiency and tuning"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the concepts of records, record types, and files, as well as the different techniques for placing file records on disk",
                      "Give examples of the application of primary, secondary, and clustering indexes",
                      "Distinguish between a non-dense index and a dense index",
                      "Implement dynamic multilevel indexes using B-trees",
                      "Explain the theory and application of internal and external hashing techniques"
                  ],
                  "hasOutcomesCT2": [
                      "Use hashing to facilitate dynamic file expansion",
                      "Describe the relationships among hashing, compression, and efficient database searches",
                      "Evaluate costs and benefits of various hashing schemes",
                      "Explain how physical database design affects database transaction efficiency"
                  ]
              },
              {
                  "code": "IM/Data Mining",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Uses of data mining",
                      "Data mining algorithms",
                      "Associative and sequential patterns",
                      "Data clustering"
                  ],
                  "hasTopicsCT2": [
                      "Market basket analysis",
                      "Data cleaning",
                      "Data visualization"
                  ],
                  "hasOutcomesCT1": [
                      "Compare and contrast different uses of data mining as evidenced in both research and application",
                      "Explain the value of finding associations in market basket data",
                      "Characterize the kinds of patterns that can be discovered by association rule mining",
                      "Describe how to extend a relational system to find patterns using association rules"
                  ],
                  "hasOutcomesCT2": [
                      "Evaluate different methodologies for effective application of data mining",
                      "Identify and characterize sources of noise, redundancy, and outliers in presented data",
                      "Identify mechanisms (on-line aggregation, anytime behavior, interactive visualization) to close the loop in the data mining process",
                      "Describe why the various close-the-loop processes improve the effectiveness of data mining"
                  ]
              },
              {
                  "code": "IM/Information Storage and Retrieval",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Documents, electronic publishing, markup, and markup languages",
                      "Tries, inverted files, PAT trees, signature files, indexing",
                      "Morphological analysis, stemming, phrases, stop lists",
                      "Term frequency distributions, uncertainty, fuzziness, weighting",
                      "Vector space, probabilistic, logical, and advanced models",
                      "Information needs, relevance, evaluation, effectiveness",
                      "Thesauri, ontologies, classification and categorization, metadata",
                      "Bibliographic information, bibliometrics, citations",
                      "Routing and (community) filtering",
                      "Multimedia search, information seeking behavior, user modeling, feedback",
                      "Information summarization and visualization"
                  ],
                  "hasTopicsCT2": [
                      "Faceted search (e.g., using citations, keywords, classification schemes)",
                      "Digital libraries",
                      "Digitization, storage, interchange, digital objects, composites, and packages",
                      "Metadata and cataloging",
                      "Naming, repositories, archives",
                      "Archiving and preservation, integrity",
                      "Spaces (conceptual, geographical, 2/3D, VR)",
                      "Architectures (agents, buses, wrappers/mediators), interoperability",
                      "Services (searching, linking, browsing, and so forth)",
                      "Intellectual property rights management, privacy, and protection (watermarking)"
                  ],
                  "hasOutcomesCT1": [
                      "Explain basic information storage and retrieval concepts",
                      "Describe what issues are specific to efficient information retrieval",
                      "Give applications of alternative search strategies and explain why the particular search strategy is appropriate for the application"
                  ],
                  "hasOutcomesCT2": [
                      "Design and implement a small to medium size information storage and retrieval system, or digital library",
                      "Describe some of the technical solutions to the problems related to archiving and preserving information in a digital library"
                  ]
              },
              {
                  "code": "IM/Multimedia Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Input and output devices, device drivers, control signals and protocols, DSPs",
                      "Standards (e.g., audio, graphics, video)",
                      "Applications, media editors, authoring systems, and authoring",
                      "Streams/structures, capture/represent/transform, spaces/domains, compression/coding"
                  ],
                  "hasTopicsCT2": [
                      "Content-based analysis, indexing, and retrieval of audio, images, animation, and video",
                      "Presentation, rendering, synchronization, multi-modal integration/interfaces",
                      "Real-time delivery, quality of service (including performance), capacity planning, audio/video conferencing, video-on-demand"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the media and supporting devices commonly associated with multimedia information and systems",
                      "Demonstrate the use of content-based information analysis in a multimedia information system",
                      "Critique multimedia presentations in terms of their appropriate use of audio, video, graphics, color, and other information presentation concepts"
                  ],
                  "hasOutcomesCT2": [
                      "Implement a multimedia application using an authoring system",
                      "For each of several media or multimedia standards, describe in non-technical language what the standard calls for, and explain how aspects of human perception might be sensitive to the limitations of that standard",
                      "Describe the characteristics of a computer system (including identification of support tools and appropriate standards) that has to host the implementation of one of a range of possible multimedia applications"
                  ]
              }
          ]
      },
      {
          "@id": "IS",
          "name": "Intelligent Systems",
          "id": "IS",
          "hasChild": [
              {
                  "code": "IS/Fundamental Issues",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Overview of AI problems, examples of successful recent AI applications",
                      "Intelligent behavior",
                      "Problem characteristics",
                      "Nature of agents"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe Turing test and the “Chinese Room” thought experiment",
                      "Differentiate between the concepts of optimal reasoning/behavior and human-like reasoning/behavior",
                      "Determine the characteristics of a given problem that an intelligent system must solve"
                  ]
              },
              {
                  "code": "IS/Basic Search Strategies",
                  "tier1": "0",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Problem spaces (states, goals and operators), problem solving by search",
                      "Factored representation (factoring state into variables)",
                      "Uninformed search (breadth-first, depth-first, depth-first with iterative deepening)",
                      "Heuristics and informed search (hill-climbing, generic best-first, A*)",
                      "Space and time efficiency of search",
                      "Two-player games (introduction to minimax search)",
                      "Constraint satisfaction (backtracking and local search methods)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Formulate an efficient problem space for a problem expressed in natural language (e.g., English) in terms of initial and goal states, and operators",
                      "Describe the role of heuristics and describe the trade-offs among completeness, optimality, time complexity, and space complexity",
                      "Describe the problem of combinatorial explosion of search space and its consequences",
                      "Select and implement an appropriate uninformed search algorithm for a problem, and characterize its time and space complexities",
                      "Select and implement an appropriate informed search algorithm for a problem by designing the necessary heuristic evaluation function",
                      "Evaluate whether a heuristic for a given problem is admissible/can guarantee optimal solution",
                      "Formulate a problem specified in natural language (e.g., English) as a constraint satisfaction problem and implement it using a chronological backtracking algorithm or stochastic local search",
                      "Compare and contrast basic search issues with game playing issues"
                  ]
              },
              {
                  "code": "IS/Basic Knowledge Representation and Reasoning",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Review of propositional and predicate logic",
                      "Resolution and theorem proving (propositional logic only)",
                      "Forward chaining, backward chaining",
                      "Review of probabilistic reasoning, Bayes theorem"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Translate a natural language (e.g., English) sentence into predicate logic statement",
                      "Convert a logic statement into clause form",
                      "Apply resolution to a set of logic statements to answer a query",
                      "Make a probabilistic inference in a real-world problem using Bayes theorem to determine the probability of a hypothesis given evidence"
                  ]
              },
              {
                  "code": "IS/Basic Machine Learning",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Definition and examples of broad variety of machine learning tasks, including classification",
                      "Inductive learning",
                      "Simple statistical-based learning, such as Naive Bayesian Classifier, decision trees",
                      "The over-fitting problem",
                      "Measuring classifier accuracy"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "List the differences among the three main styles of learning: supervised, reinforcement, and unsupervised",
                      "Identify examples of classification tasks, including the available input features and output to be predicted",
                      "Explain the difference between inductive and deductive learning",
                      "Describe over-fitting in the context of a problem",
                      "Apply the simple statistical learning algorithm such as Naive Bayesian Classifier to a classification task and measure the classifiers accuracy"
                  ]
              },
              {
                  "code": "IS/Advanced Search",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Constructing search trees, dynamic search space, combinatorial explosion of search space",
                      "Stochastic search",
                      "Implementation of A* search, beam search"
                  ],
                  "hasTopicsCT2": [
                      "Minimax search, alpha-beta pruning",
                      "Expectimax search (MDP-solving) and chance nodes"
                  ],
                  "hasOutcomesCT1": [
                      "Design and implement a genetic algorithm solution to a problem",
                      "Design and implement a simulated annealing schedule to avoid local minima in a problem",
                      "Design and implement A*/beam search to solve a problem"
                  ],
                  "hasOutcomesCT2": [
                      "Apply minimax search with alpha-beta pruning to prune search space in a two-player game",
                      "Compare and contrast genetic algorithms with classic search techniques",
                      "Compare and contrast various heuristic searches vis-a-vis applicability to a given problem"
                  ]
              },
              {
                  "code": "IS/Advanced Representation and Reasoning",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Knowledge representation issues",
                      "Non-monotonic reasoning (e.g., non-classical logics, default reasoning)",
                      "Argumentation",
                      "Reasoning about action and change (e.g., situation and event calculus)",
                      "Temporal and spatial reasoning",
                      "Rule-based Expert Systems",
                      "Semantic networks"
                  ],
                  "hasTopicsCT2": [
                      "Model-based and Case-based reasoning",
                      "Partial and totally ordered planning",
                      "Plan graphs",
                      "Hierarchical planning",
                      "Planning and execution including conditional planning and continuous planning",
                      "Mobile agent/Multi-agent planning"
                  ],
                  "hasOutcomesCT1": [
                      "Compare and contrast the most common models used for structured knowledge representation, highlighting their strengths and weaknesses",
                      "Identify the components of non-monotonic reasoning and its usefulness as a representational mechanism for belief systems",
                      "Compare and contrast the basic techniques for representing uncertainty",
                      "Compare and contrast the basic techniques for qualitative representation",
                      "Apply situation and event calculus to problems of action and change"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the distinction between temporal and spatial reasoning, and how they interrelate",
                      "Explain the difference between rule-based, case-based and model-based reasoning techniques",
                      "Define the concept of a planning system and how it differs from classical search techniques",
                      "Describe the differences between planning as search, operator-based planning, and propositional planning, providing examples of domains where each is most applicable",
                      "Explain the distinction between monotonic and non-monotonic inference"
                  ]
              },
              {
                  "code": "IS/Reasoning Under Uncertainty",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Review of basic probability",
                      "Random variables and probability distributions",
                      "Conditional Independence"
                  ],
                  "hasTopicsCT2": [
                      "Knowledge representations",
                      "Decision Theory for preferences and utility functions",
                      "Decision Theory for maximizing expected utility"
                  ],
                  "hasOutcomesCT1": [
                      "Apply Bayes’ rule to determine the probability of a hypothesis given evidence",
                      "Explain how conditional independence assertions allow for greater efficiency of probabilistic systems",
                      "Identify examples of knowledge representations for reasoning under uncertainty",
                      "State the complexity of exact inference. Identify methods for approximate inference",
                      "Design and implement at least one knowledge representation for reasoning under uncertainty"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the complexities of temporal probabilistic reasoning",
                      "Design and implement an HMM as one example of a temporal probabilistic system",
                      "Describe the relationship between preferences and utility functions",
                      "Explain how utility functions and probabilistic reasoning can be combined to make rational decisions"
                  ]
              },
              {
                  "code": "IS/Agents",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Definitions of agents",
                      "Agent architectures (e.g., reactive, layered, cognitive)",
                      "Agent theory",
                      "Rationality, game theory"
                  ],
                  "hasTopicsCT2": [
                      "Software agents, personal assistants, and information access",
                      "Learning agents",
                      "Multi-agent systems"
                  ],
                  "hasOutcomesCT1": [
                      "List the defining characteristics of an intelligent agent",
                      "Characterize and contrast the standard agent architectures",
                      "Describe the applications of agent theory to domains such as software agents, personal assistants, and believable agents"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the primary paradigms used by learning agents",
                      "Demonstrate using appropriate examples how multi-agent systems support agent interaction"
                  ]
              },
              {
                  "code": "IS/Natural Language Processing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Deterministic and stochastic grammars",
                      "Parsing algorithms",
                      "Representing meaning / Semantics",
                      "Corpus-based methods",
                      "N-grams and HMMs",
                      "Smoothing and backoff"
                  ],
                  "hasTopicsCT2": [
                      "Examples of use: POS tagging and morphology",
                      "Information retrieval",
                      "Information extraction",
                      "Language translation",
                      "Text classification, categorization"
                  ],
                  "hasOutcomesCT1": [
                      "Define and contrast deterministic and stochastic grammars, providing examples to show the adequacy of each",
                      "Simulate, apply, or implement classic and stochastic algorithms for parsing natural language",
                      "Identify the challenges of representing meaning"
                  ],
                  "hasOutcomesCT2": [
                      "List the advantages of using standard corpora. Identify examples of current corpora for a variety of NLP tasks",
                      "Identify techniques for information retrieval, language translation, and text classification"
                  ]
              },
              {
                  "code": "IS/Advanced Machine Learning",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Definition and examples of broad variety of machine learning tasks",
                      "General statistical-based learning, parameter estimation (maximum likelihood)",
                      "Inductive logic programming (ILP)",
                      "Supervised learning",
                      "Ensembles",
                      "Nearest-neighbor algorithms",
                      "Unsupervised Learning and clustering"
                  ],
                  "hasTopicsCT2": [
                      "Semi-supervised learning",
                      "Learning graphical models",
                      "Performance evaluation (such as cross-validation, area under ROC curve)",
                      "Learning theory",
                      "The problem of overfitting, the curse of dimensionality",
                      "Reinforcement learning",
                      "Application of Machine Learning algorithms to Data Mining"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the differences among the three main styles of learning: supervised, reinforcement, and unsupervised",
                      "Implement simple algorithms for supervised learning, reinforcement learning, and unsupervised learning",
                      "Determine which of the three learning styles is appropriate to a particular problem domain",
                      "Compare and contrast each of the following techniques, providing examples of when each strategy is superior: decision trees, neural networks, and belief networks"
                  ],
                  "hasOutcomesCT2": [
                      "Evaluate the performance of a simple learning system on a real-world dataset",
                      "Characterize the state of the art in learning theory, including its achievements and its shortcomings",
                      "Explain the problem of overfitting, along with techniques for detecting and managing the problem"
                  ]
              },
              {
                  "code": "IS/Robotics",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Overview: problems and progress state-of-the-art robot systems, including their sensors and an overview of their sensor processing",
                      "Problems and progress robot control architectures, e.g., deliberative vs. reactive control and Braitenberg vehicles",
                      "Problems and progress world modeling and world models",
                      "Problems and progress inherent uncertainty in sensing and in control",
                      "Configuration space and environmental maps"
                  ],
                  "hasTopicsCT2": [
                      "Interpreting uncertain sensor data",
                      "Localizing and mapping",
                      "Navigation and control",
                      "Motion planning",
                      "Multiple-robot coordination"
                  ],
                  "hasOutcomesCT1": [
                      "List capabilities and limitations of todays state-of-the-art robot systems, including their sensors and the crucial sensor processing that informs those systems",
                      "Integrate sensors, actuators, and software into a robot designed to undertake some task",
                      "Program a robot to accomplish simple tasks using deliberative, reactive, and/or hybrid control architectures",
                      "Implement fundamental motion planning algorithms within a robot configuration space"
                  ],
                  "hasOutcomesCT2": [
                      "Characterize the uncertainties associated with common robot sensors and actuators; articulate strategies for mitigating these uncertainties",
                      "List the differences among robots' representations of their external environment, including their strengths and shortcomings",
                      "Compare and contrast at least three strategies for robot navigation within known and/or unknown environments, including their strengths and shortcomings",
                      "Describe at least one approach for coordinating the actions and sensing of several robots to accomplish a single task"
                  ]
              },
              {
                  "code": "IS/Perception and Computer Vision",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Image acquisition, representation, processing and properties",
                      "Shape representation, object recognition and segmentation",
                      "Motion analysis",
                      "Audio and speech recognition"
                  ],
                  "hasTopicsCT2": [
                      "Modularity in recognition",
                      "Classification algorithms and measures of classification quality",
                      "Statistical techniques"
                  ],
                  "hasOutcomesCT1": [
                      "Summarize the importance of image and object recognition in AI and indicate several significant applications of this technology",
                      "List at least three image-segmentation approaches, such as thresholding, edge-based and region-based algorithms, along with their defining characteristics, strengths, and weaknesses",
                      "Implement 2d object recognition based on contour- and/or region-based shape representations",
                      "Distinguish the goals of sound-recognition, speech-recognition, and speaker-recognition and identify how the raw audio signal will be handled differently in each of these cases",
                      "Provide at least two examples of a transformation of a data source from one sensory domain to another, e.g., tactile data interpreted as single-band 2d images"
                  ],
                  "hasOutcomesCT2": [
                      "Implement a feature-extraction algorithm on real data, e.g., an edge or corner detector for images or vectors of Fourier coefficients describing a short slice of audio signal",
                      "Implement an algorithm combining features into higher-level percepts, e.g., a contour or polygon from visual primitives or phoneme hypotheses from an audio signal",
                      "Implement a classification algorithm that segments input percepts into output categories and quantitatively evaluates the resulting classification",
                      "Evaluate the performance of the underlying feature-extraction, relative to at least one alternative possible approach (whether implemented or not) in its contribution to the classification task (8), above",
                      "Describe at least three classification approaches, their prerequisites for applicability, their strengths, and their shortcomings"
                  ]
              }
          ]
      },
      {
          "@id": "NC",
          "name": "Networking and Communication",
          "id": "NC",
          "hasChild": [
              {
                  "code": "NC/Introduction",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Organization of the Internet (Internet Service Providers, Content Providers, etc.)",
                      "Switching techniques (e.g., circuit, packet)",
                      "Physical pieces of a network, including hosts, routers, switches, ISPs, wireless, LAN, access point, and firewalls",
                      "Layering principles (encapsulation, multiplexing)",
                      "Roles of the different layers (application, transport, network, datalink, physical)"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Articulate the organization of the Internet",
                      "List and define the appropriate network terminology",
                      "Describe the layered structure of a typical networked architecture",
                      "Identify the different types of complexity in a network (edges, core, etc.)"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "NC/Networked Applications",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Naming and address schemes (DNS, IP addresses, Uniform Resource Identifiers, etc.)",
                      "Distributed applications (client/server, peer-to-peer, cloud, etc.)",
                      "HTTP as an application layer protocol",
                      "Multiplexing with TCP and UDP",
                      "Socket APIs"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "List the differences and the relations between names and addresses in a network",
                      "Define the principles behind naming schemes and resource location",
                      "Implement a simple client-server socket-based application"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "NC/Reliable Data Delivery",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Error control (retransmission techniques, timers)",
                      "Flow control (acknowledgements, sliding window)",
                      "Performance issues (pipelining)",
                      "TCP"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the operation of reliable delivery protocols",
                      "List the factors that affect the performance of reliable delivery protocols",
                      "Design and implement a simple reliable protocol"
                  ]
              },
              {
                  "code": "NC/Routing and Forwarding",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Routing versus forwarding",
                      "Static routing",
                      "Internet Protocol (IP)",
                      "Scalability issues (hierarchical addressing)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the organization of the network layer",
                      "Describe how packets are forwarded in an IP network",
                      "List the scalability benefits of hierarchical addressing"
                  ]
              },
              {
                  "code": "NC/Local Area Networks",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Multiple Access Problem",
                      "Common approaches to multiple access (exponential-backoff, time division multiplexing, etc)",
                      "Local Area Networks",
                      "Ethernet",
                      "Switching"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe how frames are forwarded in an Ethernet network",
                      "Describe the differences between IP and Ethernet",
                      "Describe the interrelations between IP and Ethernet",
                      "Describe the steps used in one common approach to the multiple access problem"
                  ]
              },
              {
                  "code": "NC/Resource Allocation",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Need for resource allocation",
                      "Fixed allocation (TDM, FDM, WDM) versus dynamic allocation",
                      "End-to-end versus network assisted approaches",
                      "Fairness",
                      "Principles of congestion control",
                      "Approaches to Congestion (e.g., Content Distribution Networks)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe how resources can be allocated in a network",
                      "Describe the congestion problem in a large network",
                      "Compare and contrast fixed and dynamic allocation techniques",
                      "Compare and contrast current approaches to congestion"
                  ]
              },
              {
                  "code": "NC/Mobility",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Principles of cellular networks",
                      "802.11 networks",
                      "Issues in supporting mobile nodes (home agents)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the organization of a wireless network",
                      "Describe how wireless networks support mobile users"
                  ]
              },
              {
                  "code": "NC/Social Networking",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Social networks overview",
                      "Example social network platforms"
                  ],
                  "hasTopicsCT2": [
                      "Structure of social network graphs",
                      "Social network analysis"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the key principles (such as membership, trust) of social networking",
                      "Describe how existing social networks operate",
                      "Construct a social network graph from network data"
                  ],
                  "hasOutcomesCT2": [
                      "Analyze a social network to determine who the key people are",
                      "Evaluate a given interpretation of a social network question with associated data"
                  ]
              }
          ]
      },
      {
          "@id": "OS",
          "name": "Operating Systems",
          "id": "OS",
          "hasChild": [
              {
                  "code": "OS/Overview of Operating Systems",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Role and purpose of the operating system",
                      "Functionality of a typical operating system",
                      "Mechanisms to support client-server models, hand-held devices",
                      "Design issues (efficiency, robustness, flexibility, portability, security, compatibility)",
                      "Influences of security, networking, multimedia, windowing systems"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Explain the objectives and functions of modern operating systems",
                      "Analyze the tradeoffs inherent in operating system design",
                      "Describe the functions of a contemporary operating system with respect to convenience, efficiency, and the ability to evolve",
                      "Discuss networked, client-server, distributed operating systems and how they differ from single user operating systems",
                      "Identify potential threats to operating systems and the security features design to guard against them"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "OS/Operating System Principles",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Structuring methods (monolithic, layered, modular, micro-kernel models)",
                      "Abstractions, processes, and resources",
                      "Concepts of application program interfaces (APIs)",
                      "The evolution of hardware/software techniques and application needs",
                      "Device organization",
                      "Interrupts: methods and implementations",
                      "Concept of user/system state and protection, transition to kernel mode"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Explain the concept of a logical layer",
                      "Explain the benefits of building abstract layers in hierarchical fashion",
                      "Describe the value of APIs and middleware",
                      "Describe how computing resources are used by application software and managed by system software",
                      "Contrast kernel and user mode in an operating system",
                      "Discuss the advantages and disadvantages of using interrupt processing",
                      "Explain the use of a device list and driver I/O queue"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "OS/Concurrency",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "States and state diagrams",
                      "Structures (ready list, process control blocks, and so forth)",
                      "Dispatching and context switching",
                      "The role of interrupts",
                      "Managing atomic access to OS objects",
                      "Implementing synchronization primitives",
                      "Multiprocessor issues (spin-locks, reentrancy)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the need for concurrency within the framework of an operating system",
                      "Demonstrate the potential run-time problems arising from the concurrent operation of many separate tasks",
                      "Summarize the range of mechanisms that can be employed at the operating system level to realize concurrent systems and describe the benefits of each",
                      "Explain the different states that a task may pass through and the data structures needed to support the management of many tasks",
                      "Summarize techniques for achieving synchronization in an operating system (e.g., describe how to implement a semaphore using OS primitives)",
                      "Describe reasons for using interrupts, dispatching, and context switching to support concurrency in an operating system",
                      "Create state and transition diagrams for simple problem domains"
                  ]
              },
              {
                  "code": "OS/Scheduling and Dispatch",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Preemptive and non-preemptive scheduling",
                      "Schedulers and policies",
                      "Processes and threads",
                      "Deadlines and real-time issues"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Compare and contrast the common algorithms used for both preemptive and non-preemptive scheduling of tasks in operating systems, such as priority, performance comparison, and fair-share schemes",
                      "Describe relationships between scheduling algorithms and application domains",
                      "Discuss the types of processor scheduling such as short-term, medium-term, long-term, and I/O",
                      "Describe the difference between processes and threads",
                      "Compare and contrast static and dynamic approaches to real-time scheduling",
                      "Discuss the need for preemption and deadline scheduling",
                      "Identify ways that the logic embodied in scheduling algorithms are applicable to other domains, such as disk I/O, network scheduling, project scheduling, and problems beyond computing"
                  ]
              },
              {
                  "code": "OS/Memory Management",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Review of physical memory and memory management hardware",
                      "Working sets and thrashing",
                      "Caching"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain memory hierarchy and cost-performance trade-offs",
                      "Summarize the principles of virtual memory as applied to caching and paging",
                      "Evaluate the trade-offs in terms of memory size (main memory, cache memory, auxiliary memory) and processor speed",
                      "Defend the different ways of allocating memory to tasks, citing the relative merits of each",
                      "Describe the reason for and use of cache memory (performance and proximity, different dimension of how caches complicate isolation and VM abstraction)",
                      "Discuss the concept of thrashing, both in terms of the reasons it occurs and the techniques used to recognize and manage the problem"
                  ]
              },
              {
                  "code": "OS/Security and Protection",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Overview of system security",
                      "Policy/mechanism separation",
                      "Security methods and devices",
                      "Protection, access control, and authentication",
                      "Backups"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Articulate the need for protection and security in an OS",
                      "Summarize the features and limitations of an operating system used to provide protection and security",
                      "Explain the mechanisms available in an OS to control access to resources",
                      "Carry out simple system administration tasks according to a security policy, for example creating accounts, setting permissions, applying patches, and arranging for regular backups"
                  ]
              },
              {
                  "code": "OS/Virtual Machines",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Types of virtualization (including Hardware/Software, OS, Server, Service, Network)",
                      "Paging and virtual memory",
                      "Virtual file systems"
                  ],
                  "hasTopicsCT2": [
                      "Hypervisors",
                      "Portable virtualization; emulation vs. isolation",
                      "Cost of virtualization"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the concept of virtual memory and how it is realized in hardware and software",
                      "Differentiate emulation and isolation"
                  ],
                  "hasOutcomesCT2": [
                      "Evaluate virtualization trade-offs",
                      "Discuss hypervisors and the need for them in conjunction with different types of hypervisors"
                  ]
              },
              {
                  "code": "OS/Device Management",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Characteristics of serial and parallel devices",
                      "Abstracting device differences",
                      "Buffering strategies"
                  ],
                  "hasTopicsCT2": [
                      "Direct memory access",
                      "Recovery from failures"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the key difference between serial and parallel devices and identify the conditions in which each is appropriate",
                      "Identify the relationship between the physical hardware and the virtual devices maintained by the operating system",
                      "Explain buffering and describe strategies for implementing it",
                      "Differentiate the mechanisms used in interfacing a range of devices (including hand-held devices, networks, multimedia) to a computer and explain the implications of these for the design of an operating system"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the advantages and disadvantages of direct memory access and discuss the circumstances in which its use is warranted",
                      "Identify the requirements for failure recovery",
                      "Implement a simple device driver for a range of possible devices"
                  ]
              },
              {
                  "code": "OS/File Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Files: data, metadata, operations, organization, buffering, sequential, nonsequential",
                      "Directories: contents and structure",
                      "File systems: partitioning, mount/unmount, virtual file systems",
                      "Standard implementation techniques"
                  ],
                  "hasTopicsCT2": [
                      "Memory-mapped files",
                      "Special-purpose file systems",
                      "Naming, searching, access, backups",
                      "Journaling and log-structured file systems"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the choices to be made in designing file systems",
                      "Compare and contrast different approaches to file organization, recognizing the strengths and weaknesses of each"
                  ],
                  "hasOutcomesCT2": [
                      "Summarize how hardware developments have led to changes in the priorities for the design and the management of file systems",
                      "Summarize the use of journaling and how log-structured file systems enhance fault tolerance"
                  ]
              },
              {
                  "code": "OS/Real Time and Embedded Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Process and task scheduling",
                      "Memory/disk management requirements in a real-time environment"
                  ],
                  "hasTopicsCT2": [
                      "Failures, risks, and recovery",
                      "Special concerns in real-time systems"
                  ],
                  "hasOutcomesCT1": [
                      "Describe what makes a system a real-time system",
                      "Explain the presence of and describe the characteristics of latency in real-time systems"
                  ],
                  "hasOutcomesCT2": [
                      "Summarize special concerns that real-time systems present, including risk, and how these concerns are addressed"
                  ]
              },
              {
                  "code": "OS/Fault Tolerance",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Fundamental concepts: reliable and available systems",
                      "Spatial and temporal redundancy"
                  ],
                  "hasTopicsCT2": [
                      "Methods used to implement fault tolerance",
                      "Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of these techniques for the OS’s own services"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the relevance of the terms fault tolerance, reliability, and availability",
                      "Outline the range of methods for implementing fault tolerance in an operating system"
                  ],
                  "hasOutcomesCT2": [
                      "Explain how an operating system can continue functioning after a fault occurs"
                  ]
              },
              {
                  "code": "OS/System Performance Evaluation",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Why system performance needs to be evaluated",
                      "What is to be evaluated",
                      "Systems performance policies, e.g., caching, paging, scheduling, memory management, and security"
                  ],
                  "hasTopicsCT2": [
                      "Evaluation models: deterministic, analytic, simulation, or implementation-specific",
                      "How to collect evaluation data (profiling and tracing mechanisms)"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the performance measurements used to determine how a system performs"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the main evaluation models used to evaluate a system"
                  ]
              }
          ]
      },
      {
          "@id": "PBD",
          "name": "Platform-Based Development",
          "id": "PBD",
          "hasChild": [
              {
                  "code": "PBD/Introduction",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Overview of platforms (e.g., Web, Mobile, Game, Industrial)",
                      "Programming via platform-specific APIs"
                  ],
                  "hasTopicsCT2": [
                      "Overview of Platform Languages (e.g., Objective C, HTML5)",
                      "Programming under platform constraints"
                  ],
                  "hasOutcomesCT1": [
                      "Describe how platform-based development differs from general purpose programming",
                      "List characteristics of platform languages"
                  ],
                  "hasOutcomesCT2": [
                      "Write and execute a simple platform-based program",
                      "List the advantages and disadvantages of programming with platform constraints"
                  ]
              },
              {
                  "code": "PBD/Web Platforms",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Web programming languages (e.g., HTML5, Java Script, PHP, CSS)",
                      "Web platform constraints"
                  ],
                  "hasTopicsCT2": [
                      "Software as a Service (SaaS)",
                      "Web standards"
                  ],
                  "hasOutcomesCT1": [
                      "Design and Implement a simple web application",
                      "Describe the constraints that the web puts on developers",
                      "Compare and contrast web programming with general purpose programming"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the differences between Software-as-a-Service and traditional software products",
                      "Discuss how web standards impact software development",
                      "Review an existing web application against a current web standard"
                  ]
              },
              {
                  "code": "PBD/Mobile Platforms",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Mobile programming languages",
                      "Challenges with mobility and wireless communication",
                      "Location-aware applications"
                  ],
                  "hasTopicsCT2": [
                      "Performance / power tradeoffs",
                      "Mobile platform constraints",
                      "Emerging technologies"
                  ],
                  "hasOutcomesCT1": [
                      "Design and implement a mobile application for a given mobile platform",
                      "Discuss the constraints that mobile platforms put on developers"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the performance vs. power tradeoff",
                      "Compare and contrast mobile programming with general purpose programming"
                  ]
              },
              {
                  "code": "PBD/Industrial Platforms",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Types of Industrial Platforms (e.g., Mathematic, Robotic, Industrial Control)",
                      "Robotic software and its architecture"
                  ],
                  "hasTopicsCT2": [
                      "Domain-specific languages",
                      "Industrial platform constraints"
                  ],
                  "hasOutcomesCT1": [
                      "Design and implement an industrial application on a given platform (e.g., using Lego Mindstorms or Matlab)",
                      "Compare and contrast domain specific languages with general purpose programming languages"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the constraints that a given industrial platforms impose on developers"
                  ]
              },
              {
                  "code": "PBD/Game Platforms",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Types of game platforms (e.g., XBox, Wii, PlayStation)",
                      "Game platform languages (e.g., C++, Java, Lua, Python)"
                  ],
                  "hasTopicsCT2": [
                      "Game platform constraints"
                  ],
                  "hasOutcomesCT1": [
                      "Design and implement a simple application on a game platform",
                      "Describe the constraints that game platforms impose on developers"
                  ],
                  "hasOutcomesCT2": [
                      "Compare and contrast game programming with general purpose programming"
                  ]
              }
          ]
      },
      {
          "@id": "PD",
          "name": "Parallel and Distributed Computing",
          "id": "PD",
          "hasChild": [
              {
                  "code": "PD/Parallelism Fundamentals",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Multiple simultaneous computations",
                      "Goals of parallelism (e.g., throughput) versus concurrency (e.g., controlling access to shared resources)",
                      "Parallelism, communication, and coordination",
                      "Programming errors not found in sequential programming"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Distinguish using computational resources for a faster answer from managing efficient access to a shared resource",
                      "Distinguish multiple sufficient programming constructs for synchronization that may be inter-implementable but have complementary advantages",
                      "Distinguish data races from higher level races"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "PD/Parallel Decomposition",
                  "tier1": "1",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Need for communication and coordination/synchronization",
                      "Independence and partitioning"
                  ],
                  "hasTopicsCT2": [
                      "Basic knowledge of parallel decomposition concepts",
                      "Task-based decomposition",
                      "Data-parallel decomposition",
                      "Actors and reactive processes (e.g., request handlers)"
                  ],
                  "hasOutcomesCT1": [
                      "Explain why synchronization is necessary in a specific parallel program",
                      "Identify opportunities to partition a serial program into independent parallel modules"
                  ],
                  "hasOutcomesCT2": [
                      "Write a correct and scalable parallel algorithm",
                      "Parallelize an algorithm by applying task-based decomposition",
                      "Parallelize an algorithm by applying data-parallel decomposition",
                      "Write a program using actors and/or reactive processes"
                  ]
              },
              {
                  "code": "PD/Communication and Coordination",
                  "tier1": "1",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Shared Memory",
                      "Consistency, and its role in programming language guarantees for data-race-free programs"
                  ],
                  "hasTopicsCT2": [
                      "Message passing",
                      "Atomicity"
                  ],
                  "hasOutcomesCT1": [
                      "Use mutual exclusion to avoid a given race condition",
                      "Give an example of an ordering of accesses among concurrent activities (e.g., program with a data race) that is not sequentially consistent"
                  ],
                  "hasOutcomesCT2": [
                      "Give an example of a scenario in which blocking message sends can deadlock",
                      "Explain when and why multicast or event-based messaging can be preferable to alternatives",
                      "Write a program that correctly terminates when all of a set of concurrent tasks have completed",
                      "Use a properly synchronized queue to buffer data passed among activities",
                      "Explain why checks for preconditions, and actions based on these checks, must share the same unit of atomicity to be effective",
                      "Write a test program that can reveal a concurrent programming error; for example, missing an update when two activities both try to increment a variable",
                      "Describe at least one design technique for avoiding liveness failures in programs using multiple locks or semaphores",
                      "Describe the relative merits of optimistic versus conservative concurrency control under different rates of contention among updates",
                      "Give an example of a scenario in which an attempted optimistic update may never complete"
                  ]
              },
              {
                  "code": "PD/Parallel Algorithms, Analysis, and Programming",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Critical paths, work and span, and the relation to Amdahls law",
                      "Speed-up and scalability",
                      "Naturally (embarrassingly) parallel algorithms",
                      "Parallel algorithmic patterns (divide-and-conquer, map and reduce, master-workers, others)"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Define critical path, work, and span",
                      "Compute the work and span, and determine the critical path with respect to a parallel execution diagram",
                      "Define speed-up and explain the notion of an algorithm’s scalability in this regard",
                      "Identify independent tasks in a program that may be parallelized",
                      "Characterize features of a workload that allow or prevent it from being naturally parallelized",
                      "Implement a parallel divide-and-conquer (and/or graph algorithm) and empirically measure its performance relative to its sequential analog",
                      "Decompose a problem (e.g., counting the number of occurrences of some word in a document) via map and reduce operations"
                  ]
              },
              {
                  "code": "PD/Parallel Architecture",
                  "tier1": "1",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Multicore processors",
                      "Shared vs. distributed memory"
                  ],
                  "hasTopicsCT2": [
                      "Symmetric multiprocessing (SMP)",
                      "SIMD, vector processing"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the differences between shared and distributed memory"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the SMP architecture and note its key features",
                      "Characterize the kinds of tasks that are a natural match for SIMD machines"
                  ]
              },
              {
                  "code": "PD/Parallel Performance",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Load balancing",
                      "Performance measurement",
                      "Scheduling and contention"
                  ],
                  "hasTopicsCT2": [
                      "Evaluating communication overhead",
                      "Data management",
                      "Power usage and management"
                  ],
                  "hasOutcomesCT1": [
                      "Detect and correct a load imbalance",
                      "Calculate the implications of Amdahl’s law for a particular parallel algorithm",
                      "Describe how data distribution/layout can affect an algorithm’s communication costs",
                      "Detect and correct an instance of false sharing"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the impact of scheduling on parallel performance",
                      "Explain performance impacts of data locality",
                      "Explain the impact and trade-off related to power usage on parallel performance"
                  ]
              },
              {
                  "code": "PD/Distributed Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Network-based (including partitions) and node-based failures",
                      "Impact on system-wide guarantees (e.g., availability)",
                      "Distributed message sending"
                  ],
                  "hasTopicsCT2": [
                      "Distributed system design tradeoffs",
                      "Distributed service design",
                      "Core distributed algorithms"
                  ],
                  "hasOutcomesCT1": [
                      "Distinguish network faults from other kinds of failures",
                      "Explain why synchronization constructs such as simple locks are not useful in the presence of distributed faults",
                      "Write a program that performs any required marshaling and conversion into message units, such as packets, to communicate interesting data between two hosts",
                      "Measure the observed throughput and response latency across hosts in a given network",
                      "Explain why no distributed system can be simultaneously consistent, available, and partition tolerant"
                  ],
                  "hasOutcomesCT2": [
                      "Implement a simple server -- for example, a spell checking service",
                      "Explain the tradeoffs among overhead, scalability, and fault tolerance when choosing a stateful v. stateless design for a given service",
                      "Describe the scalability challenges associated with a service growing to accommodate many clients, as well as those associated with a service only transiently having many clients",
                      "Give examples of problems for which consensus algorithms such as leader election are required"
                  ]
              },
              {
                  "code": "PD/Cloud Computing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Internet-Scale computing",
                      "Cloud services"
                  ],
                  "hasTopicsCT2": [
                      "Virtualization",
                      "Cloud-based data storage"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the importance of elasticity and resource management in cloud computing",
                      "Explain strategies to synchronize a common view of shared data across a collection of devices",
                      "Explain the advantages and disadvantages of using virtualized infrastructure"
                  ],
                  "hasOutcomesCT2": [
                      "Deploy an application that uses cloud infrastructure for computing and/or data resources",
                      "Appropriately partition an application between a client and resources"
                  ]
              },
              {
                  "code": "PD/Formal Models and Semantics",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Formal models of processes and message passing, including algebras such as Communicating Sequential Processes (CSP) and pi-calculus",
                      "Formal models of parallel computation, including the Parallel Random Access Machine (PRAM) and alternatives such as Bulk Synchronous Parallel (BSP)",
                      "Formal models of computational dependencie",
                      "Models of (relaxed) shared memory consistency and their relation to programming language specifications"
                  ],
                  "hasTopicsCT2": [
                      "Algorithmic correctness criteria including linearizability",
                      "Models of algorithmic progress, including non-blocking guarantees and fairness",
                      "Techniques for specifying and checking correctness properties such as atomicity and freedom from data races"
                  ],
                  "hasOutcomesCT1": [
                      "Model a concurrent process using a formal model, such as pi-calculus",
                      "Explain the characteristics of a particular formal parallel model",
                      "Formally model a shared memory system to show if it is consistent"
                  ],
                  "hasOutcomesCT2": [
                      "Use a model to show progress guarantees in a parallel algorithm",
                      "Use formal techniques to show that a parallel algorithm is correct with respect to a safety or liveness property",
                      "Decide if a specific execution is linearizable or not"
                  ]
              }
          ]
      },
      {
          "@id": "PL",
          "name": "Programming Languages",
          "id": "PL",
          "hasChild": [
              {
                  "code": "PL/Object-Oriented Programming",
                  "tier1": "4",
                  "tier2": "6",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Object-oriented design",
                      "Definition of classes: fields, methods, and constructors",
                      "Subclasses, inheritance, and method overriding",
                      "Dynamic dispatch: definition of method-call"
                  ],
                  "hasTopicsCT2": [
                      "Subtype polymorphism; implicit upcasts in typed languages",
                      "Notion of behavioral replacement: subtypes acting like supertypes",
                      "Relationship between subtyping and inheritance",
                      "Object-oriented idioms for encapsulation",
                      "Using collection classes, iterators, and other common library components"
                  ],
                  "hasOutcomesCT1": [
                      "Design and implement a class",
                      "Use subclassing to design simple class hierarchies that allow code to be reused for distinct subclasses",
                      "Correctly reason about control flow in a program using dynamic dispatch",
                      "Compare and contrast (1) the procedural/functional approach (defining a function for each operation with the function body providing a case for each data variant) and (2) the object-oriented approach (defining a class for each data variant with the class definition providing a method for each operation). Understand both as defining a matrix of operations and variants"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the relationship between object-oriented inheritance (code-sharing and overriding) and subtyping (the idea of a subtype being usable in a context that expects the supertype)",
                      "Use object-oriented encapsulation mechanisms such as interfaces and private members",
                      "Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language"
                  ]
              },
              {
                  "code": "PL/Functional Programming",
                  "tier1": "3",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Function calls have no side effects, facilitating compositional reasoning",
                      "Variables are immutable, preventing unexpected changes to program data by other code",
                      "Data can be freely aliased or copied without introducing unintended effects from mutation",
                      "Processing structured data (e.g., trees) via functions with cases for each data variant",
                      "Associated language constructs such as discriminated unions and pattern-matching over them",
                      "Functions defined over compound data in terms of functions applied to the constituent pieces",
                      "First-class functions (taking, returning, and storing functions)"
                  ],
                  "hasTopicsCT2": [
                      "Basic meaning and definition -- creating closures at run-time by capturing the environment",
                      "Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments",
                      "Using a closure to encapsulate data in its environment",
                      "Currying and partial application",
                      "Defining higher-order operations on aggregates, especially map, reduce/fold, and filter"
                  ],
                  "hasOutcomesCT1": [
                      "Write basic algorithms that avoid assigning to mutable state or considering reference equality",
                      "Write useful functions that take and return other functions",
                      "Compare and contrast (1) the procedural/functional approach (defining a function for each operation with the function body providing a case for each data variant) and (2) the object-oriented approach (defining a class for each data variant with the class definition providing a method for each operation). Understand both as defining a matrix of operations and variants"
                  ],
                  "hasOutcomesCT2": [
                      "Correctly reason about variables and lexical scope in a program using function closures",
                      "Use functional encapsulation mechanisms such as closures and modular interfaces",
                      "Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language"
                  ]
              },
              {
                  "code": "PL/Event-Driven and Reactive Programming",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Events and event handlers",
                      "Canonical uses such as GUIs, mobile devices, robots, servers",
                      "Using a reactive framework",
                      "Externally-generated events and program-generated events",
                      "Separation of model, view, and controller"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Write event handlers for use in reactive systems, such as GUIs",
                      "Explain why an event-driven programming style is natural in domains where programs react to external events",
                      "Describe an interactive system in terms of a model, a view, and a controller"
                  ]
              },
              {
                  "code": "PL/Basic Type Systems",
                  "tier1": "1",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "A type as a set of values together with a set of operations",
                      "Association of types to variables, arguments, results, and fields",
                      "Type safety and errors caused by using values inconsistently given their intended types",
                      "Eliminating some classes of errors without running the program",
                      "Undecidability means static analysis must conservatively approximate program behavior"
                  ],
                  "hasTopicsCT2": [
                      "Generic types (parametric polymorphism)",
                      "Complementary benefits of static and dynamic typing",
                      "Enforce invariants during code development and code maintenance vs. postpone typing decisions while prototyping and conveniently allow flexible coding patterns such as heterogeneous collections",
                      "Avoid misuse of code vs. allow more code reuse",
                      "Detect incomplete programs vs. allow incomplete programs to run"
                  ],
                  "hasOutcomesCT1": [
                      "or both a primitive and a compound type, informally describe the values that have that type",
                      "For a language with a static type system, describe the operations that are forbidden statically, such as passing the wrong type of value to a function or method",
                      "Describe examples of program errors detected by a type system",
                      "For multiple programming languages, identify program properties checked statically and program properties checked dynamically",
                      "Give an example program that does not type-check in a particular language and yet would have no error if run",
                      "Use types and type-error messages to write and debug programs"
                  ],
                  "hasOutcomesCT2": [
                      "Explain how typing rules define the set of operations that are legal for a type",
                      "Write down the type rules governing the use of a particular compound type",
                      "Explain why undecidability requires type systems to conservatively approximate program behavior",
                      "Define and use program pieces (such as functions, classes, methods) that use generic types, including for collections",
                      "Discuss the differences among generics, subtyping, and overloading",
                      "Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging software"
                  ]
              },
              {
                  "code": "PL/Program Representation",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Programs that take (other) programs as input such as interpreters, compilers, type-checkers, documentation generators",
                      "Abstract syntax trees; contrast with concrete syntax",
                      "Data structures to represent code for execution, translation, or transmission"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain how programs that process other programs treat the other programs as their input data",
                      "Describe an abstract syntax tree for a small language",
                      "Describe the benefits of having program representations other than strings of source code",
                      "Write a program to process some representation of code for some purpose, such as an interpreter, an expression optimizer, or a documentation generator"
                  ]
              },
              {
                  "code": "PL/Language Translation and Execution",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Interpretation vs. compilation to native code vs. compilation to portable intermediate representation",
                      "Language translation pipeline: parsing, optional type-checking, translation, linking, execution",
                      "Run-time representation of core language constructs such as objects (method tables) and first-class functions (closures)",
                      "Run-time layout of memory: call-stack, heap, static data",
                      "Memory management"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Distinguish a language definition (what constructs mean) from a particular language implementation (compiler vs. interpreter, run-time representation of data objects, etc.)",
                      "Distinguish syntax and parsing from semantics and evaluation",
                      "Sketch a low-level run-time representation of core language constructs, such as objects or closures",
                      "Explain how programming language implementations typically organize memory into global data, text, heap, and stack sections and how features such as recursion and memory management map to this memory model",
                      "Identify and fix memory leaks and dangling-pointer dereferences",
                      "Discuss the benefits and limitations of garbage collection, including the notion of reachability"
                  ]
              },
              {
                  "code": "PL/Syntax Analysis",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Scanning (lexical analysis) using regular expressions",
                      "Parsing strategies including top-down (e.g., recursive descent, Earley parsing, or LL) and bottom-up (e.g., backtracking or LR) techniques; role of context-free grammars"
                  ],
                  "hasTopicsCT2": [
                      "Generating scanners and parsers from declarative specifications"
                  ],
                  "hasOutcomesCT1": [
                      "Use formal grammars to specify the syntax of languages",
                      "Use declarative tools to generate parsers and scanners"
                  ],
                  "hasOutcomesCT2": [
                      "Identify key issues in syntax definitions: ambiguity, associativity, precedence"
                  ]
              },
              {
                  "code": "PL/Compiler Semantic Analysis",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "High-level program representations such as abstract syntax trees",
                      "Scope and binding resolution"
                  ],
                  "hasTopicsCT2": [
                      "Type checking",
                      "Declarative specifications such as attribute grammars"
                  ],
                  "hasOutcomesCT1": [
                      "Implement context-sensitive, source-level static analyses such as type-checkers or resolving identifiers to identify their binding occurrences"
                  ],
                  "hasOutcomesCT2": [
                      "Describe semantic analyses using an attribute grammar"
                  ]
              },
              {
                  "code": "PL/Code Generation",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Procedure calls and method dispatching",
                      "Separate compilation; linking",
                      "Instruction selection"
                  ],
                  "hasTopicsCT2": [
                      "Instruction scheduling",
                      "Register allocation",
                      "Peephole optimization"
                  ],
                  "hasOutcomesCT1": [
                      "Identify all essential steps for automatically converting source code into assembly or other low-level languages",
                      "Generate the low-level code for calling functions/methods in modern languages",
                      "Discuss why separate compilation requires uniform calling conventions"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss why separate compilation limits optimization because of unknown effects of calls",
                      "Discuss opportunities for optimization introduced by naive translation and approaches for achieving optimization, such as instruction selection, instruction scheduling, register allocation, and peephole optimization"
                  ]
              },
              {
                  "code": "PL/Runtime Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Dynamic memory management approaches and techniques: malloc/free, garbage collection (mark-sweep, copying, reference counting), regions (also known as arenas or zones)",
                      "Data layout for objects and activation records"
                  ],
                  "hasTopicsCT2": [
                      "Just-in-time compilation and dynamic recompilation",
                      "Other common features of virtual machines, such as class loading, threads, and security"
                  ],
                  "hasOutcomesCT1": [
                      "Compare the benefits of different memory-management schemes, using concepts such as fragmentation, locality, and memory overhead",
                      "Discuss benefits and limitations of automatic memory management",
                      "Explain the use of metadata in run-time representations of objects and activation records, such as class pointers, array lengths, return addresses, and frame pointers"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss advantages, disadvantages, and difficulties of just-in-time and dynamic recompilation",
                      "Identify the services provided by modern language run-time systems"
                  ]
              },
              {
                  "code": "PL/Static Analysis",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and static single assignment",
                      "Undecidability and consequences for program analysi",
                      "Flow-insensitive analyses, such as type-checking and scalable pointer and alias analyses",
                      "Flow-sensitive analyses, such as forward and backward dataflow analyses"
                  ],
                  "hasTopicsCT2": [
                      "Path-sensitive analyses, such as software model checking",
                      "Tools and frameworks for defining analyses",
                      "Role of static analysis in program optimization",
                      "Role of static analysis in (partial) verification and bug-finding"
                  ],
                  "hasOutcomesCT1": [
                      "Define useful static analyses in terms of a conceptual framework such as dataflow analysis",
                      "Explain why non-trivial sound static analyses must be approximate",
                      "Communicate why an analysis is correct (sound and terminating)"
                  ],
                  "hasOutcomesCT2": [
                      "Distinguish may and must analyses",
                      "Explain why potential aliasing limits sound program analysis and how alias analysis can help",
                      "Use the results of a static analysis for program optimization and/or partial program correctness"
                  ]
              },
              {
                  "code": "PL/Advanced Programming Constructs",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Lazy evaluation and infinite streams",
                      "Control Abstractions: Exception Handling, Continuations, Monads",
                      "Object-oriented abstractions: Multiple inheritance, Mixins, Traits, Multimethods",
                      "Metaprogramming: Macros, Generative programming, Model-based development"
                  ],
                  "hasTopicsCT2": [
                      "Module systems",
                      "String manipulation via pattern-matching (regular expressions)",
                      "Dynamic code evaluation",
                      "Language support for checking assertions, invariants, and pre/post-conditions"
                  ],
                  "hasOutcomesCT1": [
                      "Use various advanced programming constructs and idioms correctly",
                      "Discuss how various advanced programming constructs aim to improve program structure, software quality, and programmer productivity"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss how various advanced programming constructs interact with the definition and implementation of other language features"
                  ]
              },
              {
                  "code": "PL/Concurrency and Parallelism",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Constructs for thread-shared variables and shared-memory synchronization",
                      "Actor models",
                      "Futures"
                  ],
                  "hasTopicsCT2": [
                      "Language support for data parallelism",
                      "Models for passing messages between sequential processes",
                      "Effect of memory-consistency models on language semantics and correct code generation"
                  ],
                  "hasOutcomesCT1": [
                      "Write correct concurrent programs using multiple programming models, such as shared memory, actors, futures, and data-parallelism primitives",
                      "Use a message-passing model to analyze a communication protocol"
                  ],
                  "hasOutcomesCT2": [
                      "Explain why programming languages do not guarantee sequential consistency in the presence of data races and what programmers must do as a result"
                  ]
              },
              {
                  "code": "PL/Type Systems",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Compositional type constructors, such as product types (for aggregates), sum types (for unions), function types, quantified types, and recursive types",
                      "Type checking",
                      "Type safety as preservation plus progress"
                  ],
                  "hasTopicsCT2": [
                      "Type inference",
                      "Static overloading"
                  ],
                  "hasOutcomesCT1": [
                      "Define a type system precisely and compositionally",
                      "For various foundational type constructors, identify the values they describe and the invariants they enforce",
                      "Precisely specify the invariants preserved by a sound type system"
                  ],
                  "hasOutcomesCT2": [
                      "Prove type safety for a simple language in terms of preservation and progress theorems",
                      "Implement a unification-based type-inference algorithm for a simple language",
                      "Explain how static overloading and associated resolution algorithms influence the dynamic behavior of programs"
                  ]
              },
              {
                  "code": "PL/Formal Semantics",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Syntax vs. semantics",
                      "Lambda Calculus",
                      "Approaches to semantics: Operational, Denotational, Axiomatic",
                      "Proofs by induction over language semantics"
                  ],
                  "hasTopicsCT2": [
                      "Formal definitions and proofs for type systems",
                      "Parametricity",
                      "Using formal semantics for systems modeling"
                  ],
                  "hasOutcomesCT1": [
                      "Give a formal semantics for a small language",
                      "Write a lambda-calculus program and show its evaluation to a normal form",
                      "Discuss the different approaches of operational, denotational, and axiomatic semantics",
                      "Use induction to prove properties of all programs in a language"
                  ],
                  "hasOutcomesCT2": [
                      "Use induction to prove properties of all programs in a language that are well-typed according to a formally defined type system",
                      "Use parametricity to establish the behavior of code given only its type",
                      "Use formal semantics to build a formal model of a software system other than a programming language"
                  ]
              },
              {
                  "code": "PL/Language Pragmatics",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Principles of language design such as orthogonality",
                      "Evaluation order, precedence, and associativity",
                      "Eager vs. delayed evaluation"
                  ],
                  "hasTopicsCT2": [
                      "Defining control and iteration constructs",
                      "External calls and system libraries"
                  ],
                  "hasOutcomesCT1": [
                      "Discuss the role of concepts such as orthogonality and well-chosen defaults in language design",
                      "Use crisp and objective criteria for evaluating language-design decisions",
                      "Give an example program whose result can differ under different rules for evaluation order, precedence, or associativity"
                  ],
                  "hasOutcomesCT2": [
                      "Show uses of delayed evaluation, such as user-defined control abstractions",
                      "Discuss the need for allowing calls to external calls and system libraries and the consequences for language implementation"
                  ]
              },
              {
                  "code": "PL/Logic Programming",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Clausal representation of data structures and algorithms",
                      "Unification"
                  ],
                  "hasTopicsCT2": [
                      "Backtracking and search",
                      "Cuts"
                  ],
                  "hasOutcomesCT1": [
                      "Use a logic language to implement a conventional algorithm"
                  ],
                  "hasOutcomesCT2": [
                      "Use a logic language to implement an algorithm employing implicit search using clauses, relations, and cuts"
                  ]
              }
          ]
      },
      {
          "@id": "SDF",
          "name": "Software Development Fundamentals",
          "id": "SDF",
          "hasChild": [
              {
                  "code": "SDF/Algorithms and Design",
                  "tier1": "11",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "The concept and properties of algorithms",
                      "The role of algorithms in the problem-solving process",
                      "Problem-solving strategies",
                      "Fundamental design concepts and principles"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Discuss the importance of algorithms in the problem-solving process",
                      "Discuss how a problem may be solved by multiple algorithms, each with different properties",
                      "Create algorithms for solving simple problems",
                      "Use a programming language to implement, test, and debug algorithms for solving simple problems",
                      "Implement, test, and debug simple recursive functions and procedures",
                      "Determine whether a recursive or iterative solution is most appropriate for a problem",
                      "Implement a divide-and-conquer algorithm for solving a problem",
                      "Apply the techniques of decomposition to break a program into smaller pieces",
                      "Identify the data components and behaviors of multiple abstract data types",
                      "Implement a coherent abstract data type, with loose coupling between components and behaviors",
                      "Identify the relative strengths and weaknesses among multiple designs or implementations for a problem"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SDF/Fundamental Programming Concepts",
                  "tier1": "10",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Basic syntax and semantics of a higher-level language",
                      "Variables and primitive data types (e.g., numbers, characters, Booleans)",
                      "Expressions and assignments",
                      "Simple I/O including file I/O",
                      "Conditional and iterative control structures",
                      "Functions and parameter passing",
                      "The concept of recursion"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Analyze and explain the behavior of simple programs involving the fundamental programming constructs variables, expressions, assignments, I/O, control constructs, functions, parameter passing, and recursion",
                      "Identify and describe uses of primitive data types",
                      "Write programs that use primitive data types",
                      "Modify and expand short programs that use standard conditional and iterative control structures and functions",
                      "Design, implement, test, and debug a program that uses each of the following fundamental programming constructs: basic computation, simple I/O, standard conditional and iterative structures, the definition of functions, and parameter passing",
                      "Write a program that uses file I/O to provide persistence across multiple executions",
                      "Choose appropriate conditional and iteration constructs for a given programming task",
                      "Describe the concept of recursion and give examples of its use",
                      "Identify the base case and the general case of a recursively-defined problem"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SDF/Fundamental Data Structures",
                  "tier1": "12",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Arrays",
                      "Records/structs (heterogeneous aggregates)",
                      "Strings and string processing",
                      "Abstract data types and their implementation",
                      "References and aliasing",
                      "Linked lists",
                      "Strategies for choosing the appropriate data structure"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Discuss the appropriate use of built-in data structures",
                      "Describe common applications for each of the following data structures: stack, queue, priority queue, set, and map",
                      "Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists, stacks, queues, sets, and maps",
                      "Compare alternative implementations of data structures with respect to performance",
                      "Describe how references allow for objects to be accessed in multiple ways",
                      "Compare and contrast the costs and benefits of dynamic and static data structure implementations",
                      "Choose the appropriate data structure for modeling a given problem"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SDF/Development Methods",
                  "tier1": "10",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Program comprehension",
                      "Program correctness",
                      "Simple refactoring",
                      "Modern programming environments",
                      "Debugging strategies",
                      "Documentation and program style"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Trace the execution of a variety of code segments and write summaries of their computations",
                      "Explain why the creation of correct program components is important in the production of high-quality software",
                      "Identify common coding errors that lead to insecure programs (e.g., buffer overflows, memory leaks, malicious code) and apply strategies for avoiding such errors",
                      "Conduct a personal code review (focused on common coding errors) on a program component using a provided checklist",
                      "Contribute to a small-team code review focused on component correctness",
                      "Describe how a contract can be used to specify the behavior of a program component",
                      "Refactor a program by identifying opportunities to apply procedural abstraction",
                      "Apply a variety of strategies to the testing and debugging of simple programs",
                      "Construct, execute and debug programs using a modern IDE and associated tools such as unit testing tools and visual debuggers",
                      "Construct and debug programs using the standard libraries available with a chosen programming language",
                      "Analyze the extent to which another programmer’s code meets documentation and programming style standards",
                      "Apply consistent documentation and program style standards that contribute to the readability and maintainability of software"
                  ],
                  "hasOutcomesCT2": []
              }
          ]
      },
      {
          "@id": "SE",
          "name": "Software Engineering",
          "id": "SE",
          "hasChild": [
              {
                  "code": "SE/Software Processes",
                  "tier1": "2",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Systems level considerations, i.e., the interaction of software with its intended environment",
                      "Introduction to software process models (e.g., waterfall, incremental, agile)",
                      "Programming in the large vs. individual programming"
                  ],
                  "hasTopicsCT2": [
                      "Evaluation of software process models"
                  ],
                  "hasOutcomesCT1": [
                      "Describe how software can interact with and participate in various systems including information management, embedded, process control, and communications systems",
                      "Describe the relative advantages and disadvantages among several major process models (e.g., waterfall, iterative, and agile)",
                      "Describe the different practices that are key components of various process models",
                      "Differentiate among the phases of software development",
                      "Describe how programming in the large differs from individual efforts with respect to understanding a large code base, code reading, understanding builds, and understanding context of changes"
                  ],
                  "hasOutcomesCT2": [
                      "Explain the concept of a software lifecycle and provide an example, illustrating its phases including the deliverables that are produced",
                      "Compare several common process models with respect to their value for development of particular classes of software systems taking into account issues such as requirement stability, size, and non-functional characteristics"
                  ]
              },
              {
                  "code": "SE/Software Project Management",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Team participation",
                      "Effort Estimation (at the personal level)",
                      "Risk"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Discuss common behaviors that contribute to the effective functioning of a team",
                      "Create and follow an agenda for a team meeting",
                      "Identify and justify necessary roles in a software development team",
                      "Understand the sources, hazards, and potential benefits of team conflict",
                      "Apply a conflict resolution strategy in a team setting",
                      "Use an ad hoc method to estimate software development effort (e.g., time) and compare to actual effort required",
                      "List several examples of software risks",
                      "Describe the impact of risk in a software development lifecycle",
                      "Describe different categories of risk in software systems"
                  ]
              },
              {
                  "code": "SE/Tools and Environments",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Software configuration management and version control",
                      "Release management",
                      "Requirements analysis and design modeling tools",
                      "Testing tools including static and dynamic analysis tools",
                      "Programming environments that automate parts of program construction processes (e.g., automated builds)",
                      "Tool integration concepts and mechanisms"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe the difference between centralized and distributed software configuration management",
                      "Describe how version control can be used to help manage software release management",
                      "Identify configuration items and use a source code control tool in a small team-based project",
                      "Describe how available static and dynamic test tools can be integrated into the software development environment",
                      "Describe the issues that are important in selecting a set of tools for the development of a particular software system, including tools for requirements tracking, design modeling, implementation, build automation, and testing",
                      "Demonstrate the capability to use software tools in support of the development of a software product of medium size"
                  ]
              },
              {
                  "code": "SE/Requirements Engineering",
                  "tier1": "1",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Describing functional requirements using, for example, use cases or users stories",
                      "Properties of requirements including consistency, validity, completeness, and feasibility"
                  ],
                  "hasTopicsCT2": [
                      "Software requirements elicitation",
                      "Describing system data using, for example, class diagrams or entity-relationship diagrams",
                      "Non-functional requirements and their relationship to software quality",
                      "Evaluation and use of requirements specifications"
                  ],
                  "hasOutcomesCT1": [
                      "List the key components of a use case or similar description of some behavior that is required for a system",
                      "Describe how the requirements engineering process supports the elicitation and validation of behavioral requirements",
                      "Interpret a given requirements model for a simple software system"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the fundamental challenges of and common techniques used for requirements elicitation",
                      "List the key components of a data model (e.g., class diagrams or ER diagrams)",
                      "Identify both functional and non-functional requirements in a given requirements specification for a software system",
                      "Conduct a review of a set of software requirements to determine the quality of the requirements with respect to the characteristics of good requirements"
                  ]
              },
              {
                  "code": "SE/Software Design",
                  "tier1": "3",
                  "tier2": "5",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "System design principles: levels of abstraction (architectural design and detailed design), separation of concerns, information hiding, coupling and cohesion, re-use of standard structures",
                      "Design Paradigms such as structured design (top-down functional decomposition), object-oriented analysis and design, event driven design, component-level design, data-structured centered, aspect oriented, function oriented, service oriented",
                      "Structural and behavioral models of software designs",
                      "Design patterns"
                  ],
                  "hasTopicsCT2": [
                      "Relationships between requirements and designs: transformation of models, design of contracts, invariants",
                      "Software architecture concepts and standard architectures (e.g. client-server, n-layer, transform centered, pipes-and-filters)",
                      "Refactoring designs using design patterns",
                      "The use of components in design: component selection, design, adaptation and assembly of components, components and patterns, components and objects"
                  ],
                  "hasOutcomesCT1": [
                      "Articulate design principles including separation of concerns, information hiding, coupling and cohesion, and encapsulation",
                      "Use a design paradigm to design a simple software system, and explain how system design principles have been applied in this design",
                      "Construct models of the design of a simple software system that are appropriate for the paradigm used to design it",
                      "Within the context of a single design paradigm, describe one or more design patterns that could be applicable to the design of a simple software system"
                  ],
                  "hasOutcomesCT2": [
                      "For a simple system suitable for a given scenario, discuss and select an appropriate design paradigm",
                      "Create appropriate models for the structure and behavior of software products from their requirements specifications",
                      "Explain the relationships between the requirements for a software product and its design, using appropriate models",
                      "For the design of a simple software system within the context of a single design paradigm, describe the software architecture of that system",
                      "Given a high-level design, identify the software architecture by differentiating among common software architectures such as 3-tier, pipe-and-filter, and client-server",
                      "Investigate the impact of software architectures selection on the design of a simple system",
                      "Apply simple examples of patterns in a software design",
                      "Describe a form of refactoring and discuss when it may be applicable",
                      "Select suitable components for use in the design of a software product",
                      "Explain how suitable components might need to be adapted for use in the design of a software product",
                      "Design a contract for a typical small software component for use in a given system"
                  ]
              },
              {
                  "code": "SE/Software Construction",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Coding practices: techniques, idioms/patterns, mechanisms for building quality programs",
                      "Coding standards",
                      "Integration strategies",
                      "Development context: “green field” vs. existing code base"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Describe techniques, coding idioms and mechanisms for implementing designs to achieve desired properties such as reliability, efficiency, and robustness",
                      "Build robust code using exception handling mechanisms",
                      "Describe secure coding and defensive coding practices",
                      "Select and use a defined coding standard in a small software project",
                      "Compare and contrast integration strategies including top-down, bottom-up, and sandwich integration",
                      "Describe the process of analyzing and implementing changes to code base developed for a specific project",
                      "Describe the process of analyzing and implementing changes to a large existing code base"
                  ]
              },
              {
                  "code": "SE/Software Verification and Validation",
                  "tier1": "0",
                  "tier2": "4",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Verification and validation concepts",
                      "Inspections, reviews, audits",
                      "Testing types, including human computer interface, usability, reliability, security, conformance to specification",
                      "Testing fundamentals",
                      "Defect tracking",
                      "Limitations of testing in particular domains, such as parallel or safety-critical systems"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Distinguish between program validation and verification",
                      "Describe the role that tools can play in the validation of software",
                      "Undertake, as part of a team activity, an inspection of a medium-size code segment",
                      "Describe and distinguish among the different types and levels of testing (unit, integration, systems, and acceptance)",
                      "Describe techniques for identifying significant test cases for integration, regression and system testing",
                      "Create and document a set of tests for a medium-size code segment",
                      "Describe how to select good regression tests and automate them",
                      "Use a defect tracking tool to manage software defects in a small software project",
                      "Discuss the limitations of testing in a particular domain"
                  ]
              },
              {
                  "code": "SE/Software Evolution",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Software development in the context of large, pre-existing code bases",
                      "Software evolution",
                      "Characteristics of maintainable software",
                      "Reengineering systems",
                      "Software reuse"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Identify the principal issues associated with software evolution and explain their impact on the software lifecycle",
                      "Estimate the impact of a change request to an existing product of medium size",
                      "Use refactoring in the process of modifying a software component",
                      "Discuss the challenges of evolving systems in a changing environment",
                      "Outline the process of regression testing and its role in release management",
                      "Discuss the advantages and disadvantages of different types of software reuse"
                  ]
              },
              {
                  "code": "SE/Software Reliability",
                  "tier1": "0",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Software reliability engineering concepts",
                      "Software reliability, system reliability and failure behavior",
                      "Fault lifecycle concepts and techniques"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain the problems that exist in achieving very high levels of reliability",
                      "Describe how software reliability contributes to system reliability",
                      "List approaches to minimizing faults that can be applied at each stage of the software lifecycle"
                  ]
              },
              {
                  "code": "SE/Formal Methods",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Role of formal specification and analysis techniques in the software development cycle",
                      "Program assertion languages and analysis approaches (including languages for writing and analyzing pre- and post-conditions, such as OCL, JML)"
                  ],
                  "hasTopicsCT2": [
                      "Formal approaches to software modeling and analysis",
                      "Tools in support of formal methods"
                  ],
                  "hasOutcomesCT1": [
                      "Describe the role formal specification and analysis techniques can play in the development of complex software and compare their use as validation and verification techniques with testing",
                      "Apply formal specification and analysis techniques to software designs and programs with low complexity",
                      "Explain the potential benefits and drawbacks of using formal specification languages"
                  ],
                  "hasOutcomesCT2": [
                      "Create and evaluate program assertions for a variety of behaviors ranging from simple through complex",
                      "Using a common formal specification language, formulate the specification of a simple software system and derive examples of test cases from the specification"
                  ]
              }
          ]
      },
      {
          "@id": "SF",
          "name": "Systems Fundamentals",
          "id": "SF",
          "hasChild": [
              {
                  "code": "SF/Computational Paradigms",
                  "tier1": "3",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections; Datapath + Control + Memory)",
                      "Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms",
                      "Application-level sequential processing: single thread",
                      "Simple application-level parallel processing: request level (web services/client-server/distributed), single thread per server, multiple threads with multiple servers",
                      "Basic concept of pipelining, overlapped processing stages",
                      "Basic concept of scaling: going faster vs. handling larger problems"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "List commonly encountered patterns of how computations are organized",
                      "Describe the basic building blocks of computers and their role in the historical development of computer architecture",
                      "Articulate the differences between single thread vs. multiple thread, single server vs. multiple server models, motivated by real world examples (e.g., cooking recipes, lines for multiple teller machines and couples shopping for food)",
                      "Articulate the concept of strong vs. weak scaling, i.e., how performance is affected by scale of problem vs. scale of resources to solve the problem. This can be motivated by the simple, real-world examples",
                      "Design a simple logic circuit using the fundamental building blocks of logic design",
                      "Use tools for capture, synthesis, and simulation to evaluate a logic design",
                      "Write a simple sequential problem and a simple parallel version of the same program",
                      "Evaluate performance of simple sequential and parallel versions of a program with different problem sizes, and be able to describe the speed-ups achieved"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SF/Cross-Layer Communications",
                  "tier1": "3",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Programming abstractions, interfaces, use of libraries",
                      "Distinction between Application and OS services, Remote Procedure Call",
                      "Application-Virtual Machine Interaction",
                      "Reliability"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Describe how computing systems are constructed of layers upon layers, based on separation of concerns, with well-defined interfaces, hiding details of low layers from the higher layers",
                      "Describe how hardware, VM, OS, and applications are additional layers of interpretation/processing",
                      "Describe the mechanisms of how errors are detected, signaled back, and handled through the layers",
                      "Construct a simple program using methods of layering, error detection and recovery, and reflection of error status across layers",
                      "Find bugs in a layered program by using tools for program tracing, single stepping, and debugging"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SF/State and State Machines",
                  "tier1": "6",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Digital vs. Analog/Discrete vs. Continuous Systems",
                      "Simple logic gates, logical expressions, Boolean logic simplification",
                      "Clocks, State, Sequencing",
                      "Combinational Logic, Sequential Logic, Registers, Memories",
                      "Computers and Network Protocols as examples of state machines"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Describe computations as a system characyterized by a known set of configurations with transitions from one unique configuration (state) to another (state)",
                      "Describe the distinction between systems whose output is only a function of their input (Combinational) and those with memory/history (Sequential)",
                      "Describe a computer as a state machine that interprets machine instructions",
                      "Explain how a program or network protocol can also be expressed as a state machine, and that alternative representations for the same computation can exist",
                      "Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing, pattern recognizers)",
                      "Derive time-series behavior of a state machine from its state machine representation"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SF/Parallelism",
                  "tier1": "3",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Sequential vs. parallel processing",
                      "Parallel programming vs. concurrent programming",
                      "Request parallelism vs. Task parallelism",
                      "Client-Server/Web Services, Thread (Fork-Join), Pipelining",
                      "Multicore architectures and hardware support for synchronization"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "For a given program, distinguish between its sequential and parallel execution, and the performance implications thereof",
                      "Demonstrate on an execution time line that parallelism events and operations can take place simultaneously (i.e., at the same time). Explain how work can be performed in less elapsed time if this can be exploited",
                      "Explain other uses of parallelism, such as for reliability/redundancy of execution",
                      "Define the differences between the concepts of Instruction Parallelism, Data Parallelism, Thread Parallelism/Multitasking, Task/Request Parallelism",
                      "Write more than one parallel program (e.g., one simple parallel program in more than one parallel programming paradigm; a simple parallel program that manages shared resources through synchronization primitives; a simple parallel program that performs simultaneous operation on partitioned data through task parallel (e.g., parallel search terms; a simple parallel program that performs step-by-step pipeline processing through message passing)",
                      "Use performance tools to measure speed-up achieved by parallel programs in terms of both problem size and number of resources"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SF/Evaluation",
                  "tier1": "3",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Performance figures of merit",
                      "Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit",
                      "CPI (Cycles per Instruction) equation as tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations",
                      "Amdahls Law: the part of the computation that cannot be sped up limits the effect of the parts that can"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Explain how the components of system architecture contribute to improving its performance",
                      "Describe Amdahls law and discuss its limitations",
                      "Design and conduct a performance-oriented experiment",
                      "Use software tools to profile and measure program performance"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SF/Resource Allocation and Scheduling",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Kinds of resources (e.g., processor share, memory, disk, net bandwidth)",
                      "Kinds of scheduling (e.g., first-come, priority)",
                      "Advantages of fair scheduling, preemptive scheduling"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Define how finite computer resources (e.g., processor share, memory, storage and network bandwidth) are managed by their careful allocation to existing entities",
                      "Describe the scheduling algorithms by which resources are allocated to competing entities, and the figures of merit by which these algorithms are evaluated, such as fairness",
                      "Implement simple schedule algorithms",
                      "Use figures of merit of alternative scheduler implementations"
                  ]
              },
              {
                  "code": "SF/Proximity",
                  "tier1": "0",
                  "tier2": "3",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Speed of light and computers (one foot per nanosecond vs. one GHz clocks)",
                      "Latencies in computer systems: memory vs. disk latencies vs. across the network memory",
                      "Caches and the effects of spatial and temporal locality on performance in processors and systems",
                      "Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture",
                      "Introduction into the processor memory hierarchy and the formula for average memory access time"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain the importance of locality in determining performance",
                      "Describe why things that are close in space take less time to access",
                      "Calculate average memory access time and describe the tradeoffs in memory hierarchy performance in terms of capacity, miss/hit rate, and access time"
                  ]
              },
              {
                  "code": "SF/Virtualization and Isolation",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Rationale for protection and predictable performance",
                      "Levels of indirection, illustrated by virtual memory for managing physical memory resources",
                      "Methods for implementing virtual memory and virtual machines"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain why it is important to isolate and protect the execution of individual programs and environments that share common underlying resources",
                      "Describe how the concept of indirection can create the illusion of a dedicated machine and its resources even when physically shared among multiple programs and environments",
                      "Measure the performance of two application instances running on separate virtual machines, and determine the effect of performance isolation"
                  ]
              },
              {
                  "code": "SF/Reliability through Redundancy",
                  "tier1": "0",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [],
                  "hasTopicsCT2": [
                      "Distinction between bugs and faults",
                      "Redundancy through check and retry",
                      "Redundancy through redundant encoding (error correcting codes, CRC, FEC)",
                      "Duplication/mirroring/replicas",
                      "Other approaches to fault tolerance and availability"
                  ],
                  "hasOutcomesCT1": [],
                  "hasOutcomesCT2": [
                      "Explain the distinction between program errors, system errors, and hardware faults (e.g., bad memory) and exceptions (e.g., attempt to divide by zero)",
                      "Articulate the distinction between detecting, handling, and recovering from faults, and the methods for their implementation",
                      "Describe the role of error correcting codes in providing error checking and correction techniques in memories, storage, and networks",
                      "Apply simple algorithms for exploiting redundant information for the purposes of data correction",
                      "Compare different error detection and correction methods for their data overhead, implementation complexity, and relative execution time for encoding, detecting, and correcting errors"
                  ]
              },
              {
                  "code": "SF/Quantitative Evaluation",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Analytical tools to guide quantitative evaluation",
                      "Order of magnitude analysis (Big-Oh notation)",
                      "Analysis of slow and fast paths of a system"
                  ],
                  "hasTopicsCT2": [
                      "Events on their effect on performance (e.g., instruction stalls, cache misses, page faults)",
                      "Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation",
                      "Microbenchmarking pitfalls"
                  ],
                  "hasOutcomesCT1": [
                      "Explain the circumstances in which a given figure of system performance metric is useful",
                      "Explain the inadequacies of benchmarks as a measure of system performance"
                  ],
                  "hasOutcomesCT2": [
                      "Use limit studies or simple calculations to produce order-of-magnitude estimates for a given performance metric in a given context",
                      "Conduct a performance experiment on a layered system to determine the effect of a system parameter on figure of system performance"
                  ]
              }
          ]
      },
      {
          "@id": "SP",
          "name": "Social Issues and Professional Practice",
          "id": "SP",
          "hasChild": [
              {
                  "code": "SP/Social Context",
                  "tier1": "1",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Social implications of computing in a networked world",
                      "Impact of social media on individualism, collectivism and culture"
                  ],
                  "hasTopicsCT2": [
                      "Growth and control of the Internet",
                      "Often referred to as the digital divide, differences in access to digital technology resources and its resulting ramifications for gender, class, ethnicity, geography, and/or underdeveloped countries",
                      "Accessibility issues, including legal requirements",
                      "Context-aware computing"
                  ],
                  "hasOutcomesCT1": [
                      "Describe positive and negative ways in which computer technology (networks, mobile computing, cloud computing) alters modes of social interaction at the personal level",
                      "Identify developers’ assumptions and values embedded in hardware and software design, especially as they pertain to usability for diverse populations including under-represented populations and the disabled",
                      "Interpret the social context of a given design and its implementation",
                      "Evaluate the efficacy of a given design and implementation using empirical data",
                      "Summarize the implications of social media on individualism versus collectivism and culture"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss how Internet access serves as a liberating force for people living under oppressive forms of government; explain how limits on Internet access are used as tools of political and social repression",
                      "Analyze the pros and cons of reliance on computing in the implementation of democracy (e.g. delivery of social services, electronic voting)",
                      "Describe the impact of the under-representation of diverse populations in the computing profession (e.g., industry culture, product diversity)",
                      "Explain the implications of context awareness in ubiquitous computing systems"
                  ]
              },
              {
                  "code": "SP/Analytical Tools",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Ethical argumentation",
                      "Ethical theories and decision-making",
                      "Moral assumptions and values"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Evaluate stakeholder positions in a given situation",
                      "Analyze basic logical fallacies in an argument",
                      "Analyze an argument to identify premises and conclusion",
                      "Illustrate the use of example and analogy in ethical argument",
                      "Evaluate ethical/social tradeoffs in technical decisions"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SP/Professional Ethics",
                  "tier1": "2",
                  "tier2": "2",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Community values and the laws by which we live",
                      "The nature of professionalism including care, attention and discipline, fiduciary responsibility, and mentoring",
                      "Keeping up-to-date as a computing professional in terms of familiarity, tools, skills, legal and professional framework as well as the ability to self-assess and progress in the computing field",
                      "Professional certification, codes of ethics, conduct, and practice, such as the ACM/IEEE-CS, SE, AITP, IFIP and international societies",
                      "Accountability, responsibility and liability (e.g. software correctness, reliability and safety, as well as ethical confidentiality of cybersecurity professionals)"
                  ],
                  "hasTopicsCT2": [
                      "The role of the computing professional in public policy",
                      "Maintaining awareness of consequences",
                      "Ethical dissent and whistle-blowing",
                      "The relationship between regional culture and ethical dilemmas",
                      "Dealing with harassment and discrimination",
                      "Forms of professional credentialing",
                      "Acceptable use policies for computing in the workplace",
                      "Ergonomics and healthy computing environments",
                      "Time to market and cost considerations versus quality professional standards"
                  ],
                  "hasOutcomesCT1": [
                      "Identify ethical issues that arise in software development and determine how to address them technically and ethically",
                      "Explain the ethical responsibility of ensuring software correctness, reliability and safety",
                      "Describe the mechanisms that typically exist for a professional to keep up-to-date",
                      "Describe the strengths and weaknesses of relevant professional codes as expressions of professionalism and guides to decision-making",
                      "Analyze a global computing issue, observing the role of professionals and government officials in managing this problem",
                      "Evaluate the professional codes of ethics from the ACM, the IEEE Computer Society, and other organizations"
                  ],
                  "hasOutcomesCT2": [
                      "Describe ways in which professionals may contribute to public policy",
                      "Describe the consequences of inappropriate professional behavior",
                      "Identify progressive stages in a whistle-blowing incident",
                      "Identify examples of how regional culture interplays with ethical dilemmas",
                      "Investigate forms of harassment and discrimination and avenues of assistance",
                      "Examine various forms of professional credentialing",
                      "Explain the relationship between ergonomics in computing environments and people’s health",
                      "Develop a computer usage/acceptable use policy with enforcement measures",
                      "Describe issues associated with industries’ push to focus on time to market versus enforcing quality professional standards"
                  ]
              },
              {
                  "code": "SP/Intellectual Property",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Philosophical foundations of intellectual property",
                      "Intellectual property rights",
                      "Intangible digital intellectual property (IDIP)",
                      "Legal foundations for intellectual property protection",
                      "Digital rights management",
                      "Copyrights, patents, trade secrets, trademarks",
                      "Plagiarism"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Discuss the philosophical bases of intellectual property",
                      "Discuss the rationale for the legal protection of intellectual property",
                      "Describe legislation aimed at digital copyright infringements",
                      "Critique legislation aimed at digital copyright infringements",
                      "Identify contemporary examples of intangible digital intellectual property",
                      "Justify uses of copyrighted materials",
                      "Evaluate the ethical issues inherent in various plagiarism detection mechanisms",
                      "Interpret the intent and implementation of software licensing",
                      "Discuss the issues involved in securing software patents",
                      "Characterize and contrast the concepts of copyright, patenting and trademarks"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SP/Privacy and Civil Liberties",
                  "tier1": "2",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Philosophical foundations of privacy rights",
                      "Legal foundations of privacy protection",
                      "Privacy implications of widespread data collection for transactional databases, data warehouses, surveillance systems, and cloud computing",
                      "Ramifications of differential privacy",
                      "Technology-based solutions for privacy protection"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Discuss the philosophical basis for the legal protection of personal privacy",
                      "Evaluate solutions to privacy threats in transactional databases and data warehouses",
                      "Describe the role of data collection in the implementation of pervasive surveillance systems (e.g., RFID, face recognition, toll collection, mobile computing)",
                      "Describe the ramifications of differential privacy",
                      "Investigate the impact of technological solutions to privacy problems"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SP/Professional Communication",
                  "tier1": "1",
                  "tier2": "0",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Reading, understanding and summarizing technical material, including source code and documentation",
                      "Writing effective technical documentation and materials",
                      "Dynamics of oral, written, and electronic team and group communication",
                      "Communicating professionally with stakeholders",
                      "Utilizing collaboration tools"
                  ],
                  "hasTopicsCT2": [],
                  "hasOutcomesCT1": [
                      "Write clear, concise, and accurate technical documents following well-defined standards for format and for including appropriate tables, figures, and references",
                      "Evaluate written technical documentation to detect problems of various kinds",
                      "Develop and deliver a good quality formal presentation",
                      "Plan interactions (e.g. virtual, face-to-face, shared documents) with others in which they are able to get their point across, and are also able to listen carefully and appreciate the points of others, even when they disagree, and are able to convey to others what they have heard",
                      "Describe the strengths and weaknesses of various forms of communication (e.g. virtual, face-to-face, shared documents)",
                      "Examine appropriate measures used to communicate with stakeholders involved in a project",
                      "Compare and contrast various collaboration tools"
                  ],
                  "hasOutcomesCT2": []
              },
              {
                  "code": "SP/Sustainability",
                  "tier1": "1",
                  "tier2": "1",
                  "isElectives": "N",
                  "hasTopicsCT1": [
                      "Being a sustainable practitioner by taking into consideration cultural and environmental impacts of implementation decisions (e.g. organizational policies, economic viability, and resource consumption)",
                      "Explore global social and environmental impacts of computer use and disposal"
                  ],
                  "hasTopicsCT2": [
                      "Environmental impacts of design choices in specific areas such as algorithms, operating systems, networks, databases, or human-computer interaction"
                  ],
                  "hasOutcomesCT1": [
                      "Identify ways to be a sustainable practitioner",
                      "Illustrate global social and environmental impacts of computer use and disposal (e-waste)"
                  ],
                  "hasOutcomesCT2": [
                      "Describe the environmental impacts of design choices within the field of computing that relate to algorithm design, operating system design, networking design, database design, etc",
                      "Investigate the social and environmental impacts of new system designs through projects"
                  ]
              },
              {
                  "code": "SP/History",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Prehistory—the world before 1946",
                      "History of computer hardware, software, networking"
                  ],
                  "hasTopicsCT2": [
                      "Pioneers of computing",
                      "History of the Internet"
                  ],
                  "hasOutcomesCT1": [
                      "Identify significant continuing trends in the history of the computing field",
                      "Identify the contributions of several pioneers in the computing field"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the historical context for several programming language paradigms",
                      "Compare daily life before and after the advent of personal computers and the Internet"
                  ]
              },
              {
                  "code": "SP/Economies of Computing",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Monopolies and their economic implications",
                      "Effect of skilled labor supply and demand on the quality of computing products",
                      "Pricing strategies in the computing domain",
                      "The phenomenon of outsourcing and off-shoring software development; impacts on employment and on economics",
                      "Consequences of globalization for the computer science profession",
                      "Differences in access to computing resources and the possible effects thereof"
                  ],
                  "hasTopicsCT2": [
                      "Cost/benefit analysis of jobs with considerations to manufacturing, hardware, software, and engineering implications",
                      "Cost estimates versus actual costs in relation to total costs",
                      "Entrepreneurship: prospects and pitfalls",
                      "Network effect or demand-side economies of scale",
                      "Use of engineering economics in dealing with finances"
                  ],
                  "hasOutcomesCT1": [
                      "Summarize the rationale for antimonopoly efforts",
                      "Identify several ways in which the information technology industry is affected by shortages in the labor supply",
                      "Identify the evolution of pricing strategies for computing goods and services"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the benefits, the drawbacks and the implications of off-shoring and outsourcing",
                      "Investigate and defend ways to address limitations on access to computing",
                      "Describe the economic benefits of network effects"
                  ]
              },
              {
                  "code": "SP/Security Policies, Laws and Computer Crimes",
                  "tier1": "0",
                  "tier2": "0",
                  "isElectives": "Y",
                  "hasTopicsCT1": [
                      "Examples of computer crimes and legal redress for computer criminals",
                      "Social engineering, identity theft and recovery",
                      "Issues surrounding the misuse of access and breaches in security",
                      "Motivations and ramifications of cyber terrorism and criminal hacking, cracking"
                  ],
                  "hasTopicsCT2": [
                      "Effects of malware, such as viruses, worms and Trojan horses",
                      "Crime prevention strategies",
                      "Security policies"
                  ],
                  "hasOutcomesCT1": [
                      "List classic examples of computer crimes and social engineering incidents with societal impact",
                      "Identify laws that apply to computer crimes",
                      "Describe the motivation and ramifications of cyber terrorism and criminal hacking",
                      "Examine the ethical and legal issues surrounding the misuse of access and various breaches in security"
                  ],
                  "hasOutcomesCT2": [
                      "Discuss the professional's role in security and the trade-offs involved",
                      "Investigate measures that can be taken by both individuals and organizations including governments to prevent or mitigate the undesirable effects of computer crimes and identity theft",
                      "Write a company-wide security policy, which includes procedures for managing passwords and employee monitoring"
                  ]
              }
          ]
      }
  ]
}