document = """
            #Differences among best, expected, and worst case behaviors of an algorithm.
            #Asymptotic analysis of upper and expected complexity bounds.
            #Big O notation: formal definition.
            #Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential.
            #Empirical measurements of performance.
            #Time and space trade-offs in algorithms.
            #Big O notation: use.
            #Little o, big omega and big theta notation.
            #Recurrence relations.
            #Analysis of iterative and recursive algorithms.
            #Some version of a Master Theorem.
            |
            #Brute-force algorithms.
            #Greedy algorithms.
            #Divide-and-conquer.
            #Recursive backtracking.
            #Dynamic Programming.
            #Branch-and-bound.
            #Heuristics.
            #Reduction: transform-and-conquer.
            |
            #Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max, and mode in a list, approximating the square root of a number, or finding the greatest common divisor.
            #Sequential and binary search algorithms.
            #Worst case quadratic sorting algorithms (selection, insertion).
            #Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort).
            #Hash tables, including strategies for avoiding and resolving collisions.
            #Common operations on binary search trees such as select min, max, insert, delete, iterate over tree.
            #Representations of graphs ( adjacency list, adjacency matrix).
            #Depth- and breadth-first traversals.
            #Heaps.
            #Shortest-path algorithms (Dijkstra and Floyd algorithms).
            #Minimum spanning tree (Prim and Kruskal algorithms).
            #Pattern matching and string/text algorithms ( substring matching, regular expression matching, longest common subsequence algorithms).
            |
            #Finite-state machines.
            #Regular expressions.
            #The halting problem.
            #Context-free grammars.
            #Introduction to the P and NP classes and the P vs NP problem.
            #Introduction to the NP-complete class and exemplary NP-complete problems ( SAT, Knapsack).
            |
            #Classic NP-complete problems.
            #Reduction Techniques.
            #Review of the classes P and NP; introduce P-space and EXP.
            #Polynomial hierarchy.
            #NP-completeness (Cook theorem).
            |
            #Regular languages.
            #Review of deterministic finite automata (DFAs).
            #Nondeterministic finite automata (NFAs).
            #Equivalence of DFAs and NFAs.
            #Review of regular expressions; their equivalence to finite automata.
            #Closure properties.
            #Proving languages non-regular, via the pumping lemma or alternative means.
            #Push-down automata (PDAs).
            #Relationship of PDAs and context-free grammars.
            #Properties of context-free languages.
            #Turing machines, or an equivalent formal model of universal computation.
            #Nondeterministic Turing machines.
            #Chomsky hierarchy.
            #The Church-Turing thesis.
            #Computability.
            #Rice Theorem.
            #Examples of uncomputable functions.
            #Implications of uncomputability.
            |
            #Balanced trees ( AVL trees, red-black trees, splay trees, treaps).
            #Graphs ( topological sort, finding strongly connected components, matching).
            #Advanced data structures ( B-trees, Fibonacci heaps).
            #String-based data structures and algorithms (suffix arrays, suffix trees, tries).
            #Network flows ( max flow Ford-Fulkerson algorithm, max flow-min cut, maximum bipartite matching).
            #Linear Programming ( duality, simplex method, interior point algorithms).
            #Number-theoretic algorithms ( modular arithmetic, primality testing, integer factorization).
            #Geometric algorithms ( points, line segments, polygons. [properties, intersections], finding convex hull, spatial decomposition, collision detection, geometric search/proximity).
            #Randomized algorithms.
            #Stochastic algorithms.
            #Approximation algorithms.
            #Amortized analysis.
            #Probabilistic analysis.
            #Online algorithms and competitive analysis.
            |
            #Overview and history of computer architecture
            #Combinational vs. sequential logic/Field programmable gate arrays as a fundamental combinational + sequential logic building block
            #Multiple representations/layers of interpretation (hardware is just another layer)
            #Computer-aided design tools that process hardware and architectural representations
            #Register transfer notation/Hardware Description Language (Verilog/VHDL)
            #Physical constraints (gate delays, fan-in, fan-out, energy/power)
            |
            #Bits, bytes, and words
            #Numeric data representation and number bases
            #Fixed- and floating-point systems
            #Signed and twos-complement representations
            #Representation of non-numeric data (character codes, graphical data)
            #Representation of records and arrays
            |
            #Basic organization of the von Neumann machine
            #Control unit; instruction fetch, decode, and execution
            #Instruction sets and types (data manipulation, control, I/O)
            #Assembly/machine language programming
            #Instruction formats
            #Addressing modes
            #Subroutine call and return mechanisms
            #I/O and interrupts
            #Heap vs. Static vs. Stack vs. Code segments
            #Shared memory multiprocessors/multicore organization
            #Introduction to SIMD vs. MIMD and the Flynn Taxonomy
            |
            #Storage systems and their technology
            #Memory hierarchy: importance of temporal and spatial locality
            #Main memory organization and operations
            #Latency, cycle time, bandwidth, and interleaving
            #Cache memories (address mapping, block size, replacement and store policy)
            #Multiprocessor cache consistency/Using the memory system for inter-core synchronization/atomic memory operations
            #Virtual memory (page table, TLB)
            #Fault handling and reliability
            #Error coding, data compression, and data integrity
            |
            #I/O fundamentals: handshaking, buffering, programmed I/O, interrupt-driven I/O
            #Interrupt structures: vectored and prioritized, interrupt acknowledgment
            #External storage, physical organization, and drives
            #Buses: bus protocols, arbitration, direct-memory access (DMA)
            #Introduction to networks: communications networks as another layer of remote access
            #Multimedia support
            #RAID architectures
            |
            #Implementation of simple datapaths, including instruction pipelining, hazard detection and resolution
            #Control unit: hardwired realization vs. microprogrammed realization
            #Instruction pipelining
            #Introduction to instruction-level parallelism (ILP)
            |
            #Power Law
            #Example SIMD and MIMD instruction sets and architectures
            #Interconnection networks (hypercube, shuffle-exchange, mesh, crossbar)
            #Shared multiprocessor memory systems and memory consistency
            #Multiprocessor cache coherence
            |
            #Superscalar architecture
            #Branch prediction, Speculative execution, Out-of-order execution
            #Prefetching
            #Vector processors and GPUs
            #Hardware support for multithreading
            #Scalability
            #Alternative architectures, such as VLIW/EPIC, and Accelerators and other kinds of Special-Purpose Processors
            |
            #Models as abstractions of situations
            #Simulations as dynamic modeling
            #Simulation techniques and tools, such as physical simulations, human-in-the-loop guided simulations, and virtual reality
            #Foundational approaches to validating models ( comparing a simulation output to real data or the output of another model)
            #Presentation of results in a form relevant to the system being modeled
            |
            #Purpose of modeling and simulation including optimization; supporting decision making, forecasting, safety considerations; for training and education
            #Tradeoffs including performance, accuracy, validity, and complexity
            #The simulation process; identification of key characteristics or behaviors, simplifying assumptions; validation of outcomes
            #Model building: use of mathematical formulas or equations, graphs, constraints; methodologies and techniques; use of time stepping for dynamic systems
            #Formal models and modeling techniques: mathematical descriptions involving simplifying assumptions and avoiding detail
            #Assessing and evaluating models and simulations in a variety of contexts; verification and validation of models and simulations
            #Important application areas including health care and diagnostics, economics and finance, city and urban planning, science, and engineering
            #Software in support of simulation and modeling; packages, languages
            |
            #The concept of an algorithm consisting of a finite number of well-defined steps, each of which completes in a finite amount of time, as does the entire process
            #Examples of well-known algorithms such as sorting and searching
            #The concept of analysis as understanding what the problem is really asking, how a problem can be approached using an algorithm, and how information is represented so that a machine can process it
            #The development or identification of a workflow
            #The process of converting an algorithm to machine-executable code
            #Software processes including lifecycle models, requirements, design, implementation, verification and maintenance
            #Machine representation of data computer arithmetic
            #Algorithms for numerically fitting data ( Newton method)
            #Architectures for numerical computation, including parallel architectures
            #Bandwidth
            #Latency
            #Scalability
            #Granularity
            #Parallelism including task, data, and event parallelism
            #Parallel architectures including processor architectures, memory and caching
            #Parallel programming paradigms including threading, message passing, event driven techniques, parallel software architectures, and MapReduce
            #Grid computing
            #The impact of architecture on computational time
            #Total time to science curve for parallelism: continuum of things
            #Computing costs,  the cost of re-computing a value vs. the cost of storing and lookup
            |
            #Principles of data visualization
            #Graphing and visualization algorithms
            #Image processing techniques
            #Scalability concerns
            |
            #Content management models, frameworks, systems, design methods
            #Digital representations of content including numbers, text, images ( raster and vector), video ( QuickTime, MPEG2, MPEG4), audio ( written score, MIDI, sampled digitized sound track) and animations; complex/composite/aggregate objects; FRBR
            #Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting
            #Content structure / management, including digital libraries and static/dynamic/stream aspects for data structures, databases
            #Content structure / management, including digital libraries and static/dynamic/stream aspects for document collections, multimedia pools, hyperbases (hypertext, hypermedia), catalogs, repositories
            #Content structure / management, including digital libraries and static/dynamic/stream aspects for ontologies, triple stores, semantic networks, rules
            #Processing and pattern recognition, including indexing, searching (including: queries and query languages; central / federated / P2P), retrieving, clustering, classifying/categorizing, analyzing/mining/extracting, rendering, reporting, handling transactions
            #User / society support for presentation and interaction, including browse, search, filter, route, visualize, share, collaborate, rate, annotate, personalize, recommend
            #Modeling, design, logical and physical implementation, using relevant systems/software
            |
            #Error, stability, convergence, including truncation and round-off
            #Function approximation including Taylor series, interpolation, extrapolation, and regression
            #Numerical differentiation and integration (Simpson Rule, explicit and implicit methods)
            #Differential equations (Euler Method, finite differences)
            |
            #Set Venn diagrams
            #Set Union, intersection, complement
            #Set Cartesian product
            #Set Power sets
            #Set Cardinality of finite sets
            #Relation Reflexivity, symmetry, transitivity
            #Relation Equivalence relations, partial orders
            #Function Surjections, injections, bijections
            #Function Inverses
            #Function Composition
            |
            #Propositional logic
            #Logical connectives
            #Truth tables
            #Normal forms (conjunctive and disjunctive)
            #Validity of well-formed formula
            #Propositional inference rules (concepts of modus ponens and modus tollens)
            #Predicate logic universal and existential quantification
            #Limitations of propositional and predicate logic ( expressiveness issues)
            |
            #Notions of implication, equivalence, converse, inverse, contrapositive, negation, and contradiction
            #The structure of mathematical proofs
            #Direct proofs
            #Disproving by counterexample
            #Proof by contradiction
            #Induction over natural numbers
            #Structural induction
            #Weak and strong induction (i.e., First and Second Principle of Induction)
            #Recursive mathematical definitions
            #Well orderings
            |
            #Counting arguments
            #The pigeonhole principle
            #Permutations and combinations
            #Solving recurrence relations
            #Basic modular arithmetic
            |
            #Trees
            #Undirected graphs
            #Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting
            #Directed graphs
            #Weighted graphs
            #Spanning trees/forests
            #Graph isomorphism
            |
            #Finite probability space, events
            #Axioms of probability and probability measures
            #Conditional probability, Bayes theorem
            #Independence
            #Integer random variables (Bernoulli, binomial)
            #Expectation, including Linearity of Expectation
            #Variance
            #Conditional Independence
            |
            #Media applications including user interfaces, audio and video editing, game engines, cad, visualization, virtual reality
            #Digitization of analog data, resolution, and the limits of human perception,  pixels for visual display, dots for laser printers, and samples for audio (HCI/Foundations)
            #Use of standard APIs for the construction of UIs and display of standard media formats (see HCI/GUI construction)
            #Standard media formats, including lossless and lossy formats
            #Additive and subtractive color models (CMYK and RGB) and why these provide a range of colors
            #Tradeoffs between storing data and re-computing data as embodied by vector and raster representations of images
            #Animation as a sequence of still images
            |
            #Rendering in nature,  the emission and scattering of light and its relation to numerical integration
            #Forward and backward rendering (i.e., ray-casting and rasterization)
            #Polygonal representation
            #Basic radiometry, similar triangles, and projection model
            #Affine and coordinate system transformations
            #Ray tracing
            #Visibility and occlusion, including solutions to this problem such as depth buffering, Painter algorithm, and ray tracing
            #The forward and backward rendering equation
            #Simple triangle rasterization
            #Rendering with a shader-based API
            #Texture mapping, including minification and magnification ( trilinear MIP-mapping)
            #Application of spatial data structures to rendering
            #Sampling and anti-aliasing
            #Scene graphs and the graphics pipeline
            |
            #Basic geometric operations such as intersection calculation and proximity tests
            #Volumes, voxels, and point-based representations
            #Parametric polynomial curves and surfaces
            #Implicit representation of curves and surfaces
            #Approximation techniques such as polynomial curves, Bezier curves, spline curves and surfaces, and non-uniform rational basis (NURB) spines, and level set method
            #Surface representation techniques including tessellation, mesh representation, mesh fairing, and mesh generation techniques such as Delaunay triangulation, marching cubes
            #Spatial subdivision techniques
            #Procedural models such as fractals, generative modeling, and L-systems
            #Graftals, cross referenced with programming languages (grammars to generated pictures)
            #Elastically deformable and freeform deformable models
            #Subdivision surfaces
            #Multiresolution modeling
            #Reconstruction
            #Constructive Solid Geometry (CSG) representation
            |
            #Solutions and approximations to the rendering equation
            #Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on rendering
            #Shadow mapping
            #Occlusion culling
            #Bidirectional Scattering Distribution function (BSDF) theory and microfacets
            #Subsurface scattering
            #Area light sources
            #Hierarchical depth buffering
            #The Light Field, image-based rendering
            #Non-photorealistic rendering
            #GPU architecture
            #Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion
            |
            #Forward and inverse kinematics
            #Collision detection and response
            #Procedural animation using noise, rules (boids/crowds), and particle systems
            #Skinning algorithms
            #Physics based motions including rigid body dynamics, physical particle systems, mass-spring networks for cloth and flesh and hair
            #Key-frame animation
            #Splines
            #Data structures for rotations, such as quaternions
            #Camera animation
            #Motion capture
            |
            #Visualization of 2D/3D scalar fields: color mapping, isosurfaces
            #Direct volume data rendering: ray-casting, transfer functions, segmentation
            #Visualization of vector fields and flow data
            #Visualization of time-varying data
            #Visualization of high-dimensional data: dimension reduction, parallel coordinates
            #Visualization of non-spatial data: multi-variate, tree/graph structured, text
            #Perceptual and cognitive foundations that drive visual abstractions
            #Visualization design
            #Evaluation of visualization methods
            #Applications of visualization
            |
            #Contexts for HCI (anything with a user interface,  webpage, business applications, mobile applications, and games)
            #Processes for user-centered development,  early focus on users, empirical testing, iterative design
            #Different measures for evaluation,  utility, efficiency, learnability, user satisfaction
            #Usability heuristics and the principles of usability testing
            #Physical capabilities that inform interaction design,  color perception, ergonomics
            #Cognitive models that inform interaction design,  attention, perception and recognition, movement, and memory; gulfs of expectation and execution
            #Social models that inform interaction design,  culture, communication, networks and organizations
            #Principles of good design and good designers; engineering tradeoffs
            #Accessibility,  interfaces for differently-abled populations ( blind, motion-impaired)
            #Interfaces for differently-aged population groups ( children, 80+)
            |
            #Principles of graphical user interfaces (GUIs)
            #Elements of visual design (layout, color, fonts, labeling)
            #Task analysis, including qualitative aspects of generating task analytic models
            #Low-fidelity (paper) prototyping
            #Quantitative evaluation techniques,  keystroke-level evaluation
            #Help and documentation
            #Handling human/system failure
            #User interface standards
            |
            #Software Architecture Patterns,  Model-View controller; command objects, online, offline
            #Interaction Design Patterns: visual hierarchy, navigational distance
            #Event management and user interaction
            #Geometry management
            #Choosing interaction styles and interaction techniques
            #Presenting information: navigation, representation, manipulation
            #Interface animation techniques ( scene graphs)
            #Widget classes and libraries
            #Modern GUI libraries (e.g. iOS, Android, JavaFX) GUI builders and UI programming environments
            #Declarative Interface Specification: Stylesheets and DOMs
            #Data-driven applications (database-backed web pages)
            #Cross-platform design
            #Design for resource-constrained devices (e.g. small, mobile devices)
            |
            #Approaches to, and characteristics of, the design process
            #Functionality and usability requirements
            #Techniques for gathering requirements,  interviews, surveys, ethnographic and contextual enquiry
            #Techniques and tools for the analysis and presentation of requirements,  reports, personas
            #Prototyping techniques and tools,  sketching, storyboards, low-fidelity prototyping, wireframes
            #Evaluation without users, using both qualitative and quantitative techniques,  walkthroughs, GOMS, expert-based analysis, heuristics, guidelines, and standards
            #Evaluation with users,  observation, think-aloud, interview, survey, experiment
            #Challenges to effective evaluation,  sampling, generalization
            #Reporting the results of evaluations
            #Internationalization, designing for users from other cultures, cross-cultural
            |
            #Choosing interaction styles and interaction techniques
            #Representing information to users: navigation, representation, manipulation
            #Approaches to design, implementation and evaluation of non-mouse interaction
            |
            #Asynchronous group communication,  e-mail, forums, social networks
            #Synchronous group communication,  chat rooms, conferencing, online games
            #Social media, social computing, and social network analysis
            #Online collaboration, smart spaces, and social coordination aspects of workflow technologies
            #Online communities
            #Software characters and intelligent agents, virtual worlds and avatars
            #Social psychology
            |
            #t-tests
            #ANOVA
            #Randomization (non-parametric) testing, within vs. between-subjects design
            #Calculating effect size
            #Exploratory data analysis
            #Presenting statistical data
            #Combining qualitative and quantitative results
            |
            #Applied psychology and security policies
            #Security economics
            #Regulatory environments - responsibility, liability and self-determination
            #Organizational vulnerabilities and threats
            #Usability design and security
            #Pretext, impersonation and fraud,  phishing and spear phishing
            #Trust, privacy and deception
            #Biometric authentication (camera, voice)
            #Identity management
            |
            #Intellectual styles and perspectives to technology and its interfaces
            #Consideration of HCI as a design discipline
            #Critically reflective HCI
            #Indicative domains of application
            |
            #Output sound
            #Output stereoscopic display
            #Output force feedback simulation, haptic devices
            #User input viewer and object tracking
            #User input pose and gesture recognition
            #User input accelerometers
            #User input fiducial markers
            #User input user interface issues
            #Physical modelling and rendering
            #System architectures
            #Networking p2p, client-server, dead reckoning, encryption, synchronization
            #Networking distributed collaboration
            |
            #CIA (Confidentiality, Integrity, Availability)
            #Concepts of risk, threats, vulnerabilities, and attack vectors
            #Authentication and authorization, access control (mandatory vs. discretionary)
            #Concept of trust and trustworthiness
            #Ethics (responsible disclosure)
            |
            #Least privilege and isolation
            #Fail-safe defaults
            #Open design
            #End-to-end security
            #Defense in depth ( defensive programming, layered defense)
            #Security by design
            #Tensions between security and other design goals
            #Complete mediation
            #Use of vetted security components
            #Economy of mechanism (reducing trusted computing base, minimize attack surface)
            #Usable security
            #Security composability
            #Prevention, detection, and deterrence
            |
            #Input validation and data sanitization
            #Choice of programming language and type-safe languages#,
            #Examples of input validation and data sanitization errors such as Buffer overflows, Integer errors, SQL injection, XSS vulnerability
            #Race conditions
            #Correct handling of exceptions and unexpected behaviors
            #Correct usage of third-party components
            #Effectively deploying security updates
            |
            #Attacker goals, capabilities, and motivations (such as underground economy, digital espionage, cyberwarfare, insider threats, hacktivism, advanced persistent threats)
            #Examples of malware ( viruses, worms, spyware, botnets, Trojan horses or rootkits)
            #Denial of Service (DoS) and Distributed Denial of Service (DDoS)
            #Social engineering ( phishing)
            |
            #Network specific threats and attack types ( denial of service, spoofing, sniffing and traffic redirection, man-in-the-middle, message integrity attacks, routing attacks, and traffic analysis)
            #Use of cryptography for data and network security
            #Architectures for secure networks ( secure channels, secure routing protocols, secure DNS, VPNs, anonymous communication protocols, isolation)
            #Defense mechanisms and countermeasures ( network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots, tracebacks)
            |
            #Basic Cryptography Terminology covering notions pertaining to the different (communication) partners, secure/unsecure channel, attackers and their capabilities, encryption, decryption, keys and their characteristics, signatures
            #Cipher types ( Caesar cipher, affine cipher) together with typical attack methods such as frequency analysis
            #Public Key Infrastructure support for digital signature and encryption and its challenges
            |
            #Web security model
            #Session management, authentication
            #Application vulnerabilities and defenses
            #Client-side security
            #Server-side security tools, e.g. Web Application Firewalls (WAFs) and fuzzers
            |
            #Code integrity and code signing
            #Secure boot, measured boot, and root of trust
            #Attestation
            #TPM and secure co-processors
            #Security threats from peripherals,  DMA, IOMMU
            #Physical attacks: hardware Trojans, memory probes, cold boot attacks
            #Security of embedded devices,  medical devices, cars
            #Trusted path
            |
            #Privacy policy
            #Inference controls/statistical disclosure limitation
            #Backup policy, password refresh policy
            #Breach disclosure policy
            #Data collection and retention policies
            #Supply chain policy
            #Cloud security tradeoffs
            |
            #Basic Principles and methodologies for digital forensics
            #Design systems with forensic needs in mind
            #Rules of Evidence - general concepts and differences between jurisdictions and Chain of Custody
            #Search and Seizure of evidence: legal and procedural requirements
            #Digital Evidence methods and standards
            #Techniques and standards for Preservation of Data
            #Legal and Reporting Issues including working as an expert witness
            #OS/File System Forensics
            #Application Forensics
            #Web Forensics
            #Network Forensics
            #Mobile Device Forensics
            #Computer/network/system attacks
            #Attack detection and investigation
            #Anti-forensics
            |
            #Building security into the software development lifecycle
            #Secure design principles and patterns
            #Secure software specifications and requirements
            #Secure software development practices
            #Secure testing - the process of testing that security requirements are met (including static and dynamic analysis)
            #Software quality assurance and benchmarking measurements
            |
            #Information systems as socio-technical systems
            #Basic information storage and retrieval (IS&R) concepts
            #Information capture and representation
            #Supporting human needs: searching, retrieving, linking, browsing, navigating
            #Information management applications
            #Declarative and navigational queries, use of links
            #Analysis and indexing
            #Quality issues: reliability, scalability, efficiency, and effectiveness
            |
            #Approaches to and evolution of database systems
            #Components of database systems
            #Design of core DBMS functions ( query mechanisms, transaction management, buffer management, access methods
            #Database architecture and data independence
            #Use of a declarative query language
            #Systems supporting structured and/or stream content
            |
            #Data modeling
            #Conceptual models ( entity-relationship, UML diagrams)
            #Spreadsheet models
            #Relational data models
            #Object-oriented models
            #Semi-structured data model (expressed using DTD or XML Schema, for example)
            |
            #The impact of indices on query performance
            #The basic structure of an index
            #Keeping a buffer of data in memory
            #Creating indexes with SQL
            #Indexing text
            #Indexing the web ( web crawling)
            |
            #Mapping conceptual schema to a relational schema
            #Entity and referential integrity
            #Relational algebra and relational calculus
            #Relational Database design
            #Functional dependency
            #Decomposition of a schema; lossless-join and dependency-preservation properties of a decomposition
            #Candidate keys, superkeys, and closure of a set of attributes
            #Normal forms (BCNF)
            #Multi-valued dependency (4NF)
            #Join dependency (PJNF, 5NF)
            #Representation theory
            |
            #Overview of database languages
            #SQL (data definition, query formulation, update sublanguage, constraints, integrity)
            #Selections
            #Projections
            #Select-project-join
            #Aggregates and group-by
            #Subqueries
            #QBE and 4th-generation environments
            #Different ways to invoke non-procedural queries in conventional languages
            #Introduction to other major query languages ( XPATH, SPARQL)
            #Stored procedures
            |
            #Transactions
            #Failure and recovery
            #Concurrency control
            #Interaction of transaction management with storage, especially buffering
            |
            #Distributed DBMS
            #Parallel DBMS
            |
            #Storage and file structure
            #Indexed files
            #Hashed files
            #Signature files
            #B-trees
            #Files with dense index
            #Files with variable length records
            #Database efficiency and tuning
            |
            #Uses of data mining
            #Data mining algorithms
            #Associative and sequential patterns
            #Data clustering
            #Market basket analysis
            #Data cleaning
            #Data visualization
            |
            #Documents, electronic publishing, markup, and markup languages
            #Tries, inverted files, PAT trees, signature files, indexing
            #Morphological analysis, stemming, phrases, stop lists
            #Term frequency distributions, uncertainty, fuzziness, weighting
            #Vector space, probabilistic, logical, and advanced models
            #Information needs, relevance, evaluation, effectiveness
            #Thesauri, ontologies, classification and categorization, metadata
            #Bibliographic information, bibliometrics, citations
            #Routing and (community) filtering
            #Multimedia search, information seeking behavior, user modeling, feedback
            #Information summarization and visualization
            #Faceted search ( using citations, keywords, classification schemes)
            #Digital libraries
            #Digitization, storage, interchange, digital objects, composites, and packages
            #Metadata and cataloging
            #Naming, repositories, archives
            #Archiving and preservation, integrity
            #Spaces (conceptual, geographical, 2/3D, VR)
            #Architectures (agents, buses, wrappers/mediators), interoperability
            #Services (searching, linking, browsing, and so forth)
            #Intellectual property rights management, privacy, and protection (watermarking)
            |
            #Input and output devices, device drivers, control signals and protocols, DSPs
            #Standards ( audio, graphics, video)
            #Applications, media editors, authoring systems, and authoring
            #Streams/structures, capture/represent/transform, spaces/domains, compression/coding
            #Content-based analysis, indexing, and retrieval of audio, images, animation, and video
            #Presentation, rendering, synchronization, multi-modal integration/interfaces
            #Real-time delivery, quality of service (including performance), capacity planning, audio/video conferencing, video-on-demand
            |
            #Overview of AI problems, examples of successful recent AI applications
            #Intelligent behavior
            #Problem characteristics
            #Nature of agents
            |
            #Problem spaces (states, goals and operators), problem solving by search
            #Factored representation (factoring state into variables)
            #Uninformed search (breadth-first, depth-first, depth-first with iterative deepening)
            #Heuristics and informed search (hill-climbing, generic best-first, A*)
            #Space and time efficiency of search
            #Two-player games (introduction to minimax search)
            #Constraint satisfaction (backtracking and local search methods)
            |
            #Review of propositional and predicate logic
            #Resolution and theorem proving (propositional logic only)
            #Forward chaining, backward chaining
            #Review of probabilistic reasoning, Bayes theorem
            |
            #Definition and examples of broad variety of machine learning tasks, including classification
            #Inductive learning
            #Simple statistical-based learning, such as Naive Bayesian Classifier, decision trees
            #The over-fitting problem
            #Measuring classifier accuracy
            |
            #Constructing search trees, dynamic search space, combinatorial explosion of search space
            #Stochastic search
            #Implementation of A* search, beam search
            #Minimax search, alpha-beta pruning
            #Expectimax search (MDP-solving) and chance nodes
            |
            #Knowledge representation issues
            #Non-monotonic reasoning ( non-classical logics, default reasoning)
            #Argumentation
            #Reasoning about action and change ( situation and event calculus)
            #Temporal and spatial reasoning
            #Rule-based Expert Systems
            #Semantic networks
            #Model-based and Case-based reasoning
            #Partial and totally ordered planning
            #Plan graphs
            #Hierarchical planning
            #Planning and execution including conditional planning and continuous planning
            #Mobile agent/Multi-agent planning
            |
            #Review of basic probability
            #Random variables and probability distributions
            #Conditional Independence
            #Knowledge representations
            #Decision Theory for preferences and utility functions
            #Decision Theory for maximizing expected utility
            |
            #Definitions of agents
            #Agent architectures ( reactive, layered, cognitive)
            #Agent theory
            #Rationality, game theory
            #Software agents, personal assistants, and information access
            #Learning agents
            #Multi-agent systems
            |
            #Deterministic and stochastic grammars
            #Parsing algorithms
            #Representing meaning / Semantics
            #Corpus-based methods
            #N-grams and HMMs
            #Smoothing and backoff
            #Examples of use: POS tagging and morphology
            #Information retrieval
            #Information extraction
            #Language translation
            #Text classification, categorization
            |
            #Definition and examples of broad variety of machine learning tasks
            #General statistical-based learning, parameter estimation (maximum likelihood)
            #Inductive logic programming (ILP)
            #Supervised learning
            #Ensembles
            #Nearest-neighbor algorithms
            #Unsupervised Learning and clustering
            #Semi-supervised learning
            #Learning graphical models
            #Performance evaluation (such as cross-validation, area under ROC curve)
            #Learning theory
            #The problem of overfitting, the curse of dimensionality
            #Reinforcement learning
            #Application of Machine Learning algorithms to Data Mining
            |
            #Overview: problems and progress state-of-the-art robot systems, including their sensors and an overview of their sensor processing
            #Problems and progress robot control architectures,  deliberative vs. reactive control and Braitenberg vehicles
            #Problems and progress world modeling and world models
            #Problems and progress inherent uncertainty in sensing and in control
            #Configuration space and environmental maps
            #Interpreting uncertain sensor data
            #Localizing and mapping
            #Navigation and control
            #Motion planning
            #Multiple-robot coordination
            |
            #Image acquisition, representation, processing and properties
            #Shape representation, object recognition and segmentation
            #Motion analysis
            #Audio and speech recognition
            #Modularity in recognition
            #Classification algorithms and measures of classification quality
            #Statistical techniques
            |
            #Organization of the Internet (Internet Service Providers, Content Providers, etc.)
            #Switching techniques ( circuit, packet)
            #Physical pieces of a network, including hosts, routers, switches, ISPs, wireless, LAN, access point, and firewalls
            #Layering principles (encapsulation, multiplexing)
            #Roles of the different layers (application, transport, network, datalink, physical)
            |
            #Naming and address schemes (DNS, IP addresses, Uniform Resource Identifiers, etc.)
            #Distributed applications (client/server, peer-to-peer, cloud, etc.)
            #HTTP as an application layer protocol
            #Multiplexing with TCP and UDP
            #Socket APIs
            |
            #Error control (retransmission techniques, timers)
            #Flow control (acknowledgements, sliding window)
            #Performance issues (pipelining)
            #TCP
            |
            #Routing versus forwarding
            #Static routing
            #Internet Protocol (IP)
            #Scalability issues (hierarchical addressing)
            |
            #Multiple Access Problem
            #Common approaches to multiple access (exponential-backoff, time division multiplexing, etc)
            #Local Area Networks
            #Ethernet
            #Switching
            |
            #Need for resource allocation
            #Fixed allocation (TDM, FDM, WDM) versus dynamic allocation
            #End-to-end versus network assisted approaches
            #Fairness
            #Principles of congestion control
            #Approaches to Congestion ( Content Distribution Networks)
            |
            #Principles of cellular networks
            #802.11 networks
            #Issues in supporting mobile nodes (home agents)
            |
            #Social networks overview
            #Example social network platforms
            #Structure of social network graphs
            #Social network analysis
            |
            #Role and purpose of the operating system
            #Functionality of a typical operating system
            #Mechanisms to support client-server models, hand-held devices
            #Design issues (efficiency, robustness, flexibility, portability, security, compatibility)
            #Influences of security, networking, multimedia, windowing systems
            |
            #Structuring methods (monolithic, layered, modular, micro-kernel models)
            #Abstractions, processes, and resources
            #Concepts of application program interfaces (APIs)
            #The evolution of hardware/software techniques and application needs
            #Device organization
            #Interrupts: methods and implementations
            #Concept of user/system state and protection, transition to kernel mode
            |
            #States and state diagrams
            #Structures (ready list, process control blocks, and so forth)
            #Dispatching and context switching
            #The role of interrupts
            #Managing atomic access to OS objects
            #Implementing synchronization primitives
            #Multiprocessor issues (spin-locks, reentrancy)
            |
            #Preemptive and non-preemptive scheduling
            #Schedulers and policies
            #Processes and threads
            #Deadlines and real-time issues
            |
            #Review of physical memory and memory management hardware
            #Working sets and thrashing
            #Caching
            |
            #Overview of system security
            #Policy/mechanism separation
            #Security methods and devices
            #Protection, access control, and authentication
            #Backups
            |
            #Types of virtualization (including Hardware/Software, OS, Server, Service, Network)
            #Paging and virtual memory
            #Virtual file systems
            #Hypervisors
            #Portable virtualization; emulation vs. isolation
            #Cost of virtualization
            |
            #Characteristics of serial and parallel devices
            #Abstracting device differences
            #Buffering strategies
            #Direct memory access
            #Recovery from failures
            |
            #Files: data, metadata, operations, organization, buffering, sequential, nonsequential
            #Directories: contents and structure
            #File systems: partitioning, mount/unmount, virtual file systems
            #Standard implementation techniques
            #Memory-mapped files
            #Special-purpose file systems
            #Naming, searching, access, backups
            #Journaling and log-structured file systems
            |
            #Process and task scheduling
            #Memory/disk management requirements in a real-time environment
            #Failures, risks, and recovery
            #Special concerns in real-time systems
            |
            #Fundamental concepts: reliable and available systems
            #Spatial and temporal redundancy
            #Methods used to implement fault tolerance
            #Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of these techniques for the OS own services
            |
            #Why system performance needs to be evaluated
            #What is to be evaluated
            #Systems performance policies,  caching, paging, scheduling, memory management, and security
            #Evaluation models: deterministic, analytic, simulation, or implementation-specific
            #How to collect evaluation data (profiling and tracing mechanisms)
            |
            #Overview of platforms ( Web, Mobile, Game, Industrial)
            #Programming via platform-specific APIs
            #Overview of Platform Languages ( Objective C, HTML5)
            #Programming under platform constraints
            |
            #Web programming languages ( HTML5, Java Script, PHP, CSS)
            #Web platform constraints
            #Software as a Service (SaaS)
            #Web standards
            |
            #Mobile programming languages
            #Challenges with mobility and wireless communication
            #Location-aware applications
            #Performance / power tradeoffs
            #Mobile platform constraints
            #Emerging technologies
            |
            #Types of Industrial Platforms ( Mathematic, Robotic, Industrial Control)
            #Robotic software and its architecture
            #Domain-specific languages
            #Industrial platform constraints
            |
            #Types of game platforms ( XBox, Wii, PlayStation)
            #Game platform languages ( C++, Java, Lua, Python)
            #Game platform constraints
            |
            #Multiple simultaneous computations
            #Goals of parallelism ( throughput) versus concurrency ( controlling access to shared resources)
            #Parallelism, communication, and coordination
            #Programming errors not found in sequential programming
            |
            #Need for communication and coordination/synchronization
            #Independence and partitioning
            #Basic knowledge of parallel decomposition concepts
            #Task-based decomposition
            #Data-parallel decomposition
            #Actors and reactive processes ( request handlers)
            |
            #Shared Memory
            #Consistency, and its role in programming language guarantees for data-race-free programs
            #Message passing
            #Atomicity
            |
            #Critical paths, work and span, and the relation to Amdahls law
            #Speed-up and scalability
            #Naturally (embarrassingly) parallel algorithms#
            #Parallel algorithmic patterns (divide-and-conquer, map and reduce, master-workers, others)
            |
            #Multicore processors
            #Shared vs. distributed memory
            #Symmetric multiprocessing (SMP)
            #SIMD, vector processing
            |
            #Load balancing
            #Performance measurement
            #Scheduling and contention
            #Evaluating communication overhead
            #Data management
            #Power usage and management
            |
            #Network-based (including partitions) and node-based failures
            #Impact on system-wide guarantees ( availability)
            #Distributed message sending
            #Distributed system design tradeoffs
            #Distributed service design
            #Core distributed algorithms
            |
            #Internet-Scale computing
            #Cloud services
            #Virtualization
            #Cloud-based data storage
            |
            #Formal models of processes and message passing, including algebras such as Communicating Sequential Processes (CSP) and pi-calculus
            #Formal models of parallel computation, including the Parallel Random Access Machine (PRAM) and alternatives such as Bulk Synchronous Parallel (BSP)
            #Formal models of computational dependencie
            #Models of (relaxed) shared memory consistency and their relation to programming language specifications
            #Algorithmic correctness criteria including linearizability
            #Models of algorithmic progress, including non-blocking guarantees and fairness
            #Techniques for specifying and checking correctness properties such as atomicity and freedom from data races
            |
            #Object-oriented design
            #Definition of classes: fields, methods, and constructors
            #Subclasses, inheritance, and method overriding
            #Dynamic dispatch: definition of method-call
            #Subtype polymorphism; implicit upcasts in typed languages
            #Notion of behavioral replacement: subtypes acting like supertypes
            #Relationship between subtyping and inheritance
            #Object-oriented idioms for encapsulation
            #Using collection classes, iterators, and other common library components
            |
            #Function calls have no side effects, facilitating compositional reasoning
            #Variables are immutable, preventing unexpected changes to program data by other code
            #Data can be freely aliased or copied without introducing unintended effects from mutation
            #Processing structured data ( trees) via functions with cases for each data variant
            #Associated language constructs such as discriminated unions and pattern-matching over them
            #Functions defined over compound data in terms of functions applied to the constituent pieces
            #First-class functions (taking, returning, and storing functions)
            #Basic meaning and definition -- creating closures at run-time by capturing the environment
            #Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments
            #Using a closure to encapsulate data in its environment
            #Currying and partial application
            #Defining higher-order operations on aggregates, especially map, reduce/fold, and filter
            |
            #Events and event handlers
            #Canonical uses such as GUIs, mobile devices, robots, servers
            #Using a reactive framework
            #Externally-generated events and program-generated events
            #Separation of model, view, and controller
            |
            #A type as a set of values together with a set of operations
            #Association of types to variables, arguments, results, and fields
            #Type safety and errors caused by using values inconsistently given their intended types
            #Eliminating some classes of errors without running the program
            #Undecidability means static analysis must conservatively approximate program behavior
            #Generic types (parametric polymorphism)
            #Complementary benefits of static and dynamic typing
            #Enforce invariants during code development and code maintenance vs. postpone typing decisions while prototyping and conveniently allow flexible coding patterns such as heterogeneous collections
            #Avoid misuse of code vs. allow more code reuse
            #Detect incomplete programs vs. allow incomplete programs to run
            |
            #Programs that take (other) programs as input such as interpreters, compilers, type-checkers, documentation generators
            #Abstract syntax trees; contrast with concrete syntax
            #Data structures to represent code for execution, translation, or transmission
            |
            #Interpretation vs. compilation to native code vs. compilation to portable intermediate representation
            #Language translation pipeline: parsing, optional type-checking, translation, linking, execution
            #Run-time representation of core language constructs such as objects (method tables) and first-class functions (closures)
            #Run-time layout of memory: call-stack, heap, static data
            #Memory management
            |
            #Scanning (lexical analysis) using regular expressions
            #Parsing strategies including top-down ( recursive descent, Earley parsing, or LL) and bottom-up ( backtracking or LR) techniques; role of context-free grammars
            #Generating scanners and parsers from declarative specifications
            |
            #High-level program representations such as abstract syntax trees
            #Scope and binding resolution
            #Type checking
            #Declarative specifications such as attribute grammars
            |
            #Procedure calls and method dispatching
            #Separate compilation; linking
            #Instruction selection
            #Instruction scheduling
            #Register allocation
            #Peephole optimization
            |
            #Dynamic memory management approaches and techniques: malloc/free, garbage collection (mark-sweep, copying, reference counting), regions (also known as arenas or zones)
            #Data layout for objects and activation records
            #Just-in-time compilation and dynamic recompilation
            #Other common features of virtual machines, such as class loading, threads, and security
            |
            #Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and static single assignment
            #Undecidability and consequences for program analysis
            #Flow-insensitive analyses, such as type-checking and scalable pointer and alias analyses
            #Flow-sensitive analyses, such as forward and backward dataflow analyses
            #Path-sensitive analyses, such as software model checking
            #Tools and frameworks for defining analyses
            #Role of static analysis in program optimization
            #Role of static analysis in (partial) verification and bug-finding
            |
            #Lazy evaluation and infinite streams
            #Control Abstractions: Exception Handling, Continuations, Monads
            #Object-oriented abstractions: Multiple inheritance, Mixins, Traits, Multimethods
            #Metaprogramming: Macros, Generative programming, Model-based development
            #Module systems
            #String manipulation via pattern-matching (regular expressions)
            #Dynamic code evaluation
            #Language support for checking assertions, invariants, and pre/post-conditions
            |
            #Constructs for thread-shared variables and shared-memory synchronization
            #Actor models
            #Futures
            #Language support for data parallelism
            #Models for passing messages between sequential processes
            #Effect of memory-consistency models on language semantics and correct code generation
            |
            #Compositional type constructors, such as product types (for aggregates), sum types (for unions), function types, quantified types, and recursive types
            #Type checking
            #Type safety as preservation plus progress
            #Type inference
            #Static overloading
            |
            #Syntax vs. semantics
            #Lambda Calculus
            #Approaches to semantics: Operational, Denotational, Axiomatic
            #Proofs by induction over language semantics
            #Formal definitions and proofs for type systems
            #Parametricity
            #Using formal semantics for systems modeling
            |
            #Principles of language design such as orthogonality
            #Evaluation order, precedence, and associativity
            #Eager vs. delayed evaluation
            #Defining control and iteration constructs
            #External calls and system libraries
            |
            #Clausal representation of data structures and algorithms
            #Unification
            #Backtracking and search
            #Cuts
            |
            #The concept and properties of algorithms
            #The role of algorithms in the problem-solving process
            #Problem-solving strategies
            #Fundamental design concepts and principles
            |
            #Basic syntax and semantics of a higher-level language
            #Variables and primitive data types ( numbers, characters, Booleans)
            #Expressions and assignments
            #Simple I/O including file I/O
            #Conditional and iterative control structures
            #Functions and parameter passing
            #The concept of recursion
            |
            #Arrays
            #Records/structs (heterogeneous aggregates)
            #Strings and string processing
            #Abstract data types and their implementation
            #References and aliasing
            #Linked lists
            #Strategies for choosing the appropriate data structure
            |
            #Program comprehension
            #Program correctness
            #Simple refactoring
            #Modern programming environments
            #Debugging strategies
            #Documentation and program style
            |
            #Systems level considerations, i.e., the interaction of software with its intended environment
            #Introduction to software process models ( waterfall, incremental, agile)
            #Programming in the large vs. individual programming
            #Evaluation of software process models
            |
            #Team participation
            #Effort Estimation (at the personal level)
            #Risk
            |
            #Software configuration management and version control
            #Release management
            #Requirements analysis and design modeling tools
            #Testing tools including static and dynamic analysis tools
            #Programming environments that automate parts of program construction processes ( automated builds)
            #Tool integration concepts and mechanisms
            |
            #Describing functional requirements using, for example, use cases or users stories
            #Properties of requirements including consistency, validity, completeness, and feasibility
            #Software requirements elicitation
            #Describing system data using, for example, class diagrams or entity-relationship diagrams
            #Non-functional requirements and their relationship to software quality
            #Evaluation and use of requirements specifications
            |
            #System design principles: levels of abstraction (architectural design and detailed design), separation of concerns, information hiding, coupling and cohesion, re-use of standard structures
            #Design Paradigms such as structured design (top-down functional decomposition), object-oriented analysis and design, event driven design, component-level design, data-structured centered, aspect oriented, function oriented, service oriented
            #Structural and behavioral models of software designs
            #Design patterns
            #Relationships between requirements and designs: transformation of models, design of contracts, invariants
            #Software architecture concepts and standard architectures (e.g. client-server, n-layer, transform centered, pipes-and-filters)
            #Refactoring designs using design patterns
            #The use of components in design: component selection, design, adaptation and assembly of components, components and patterns, components and objects
            |
            #Coding practices: techniques, idioms/patterns, mechanisms for building quality programs
            #Coding standards
            #Integration strategies
            #Development context: green field vs. existing code base
            |
            #Verification and validation concepts
            #Inspections, reviews, audits
            #Testing types, including human computer interface, usability, reliability, security, conformance to specification
            #Testing fundamentals
            #Defect tracking
            #Limitations of testing in particular domains, such as parallel or safety-critical systems
            |
            #Software development in the context of large, pre-existing code bases
            #Software evolution
            #Characteristics of maintainable software
            #Reengineering systems
            #Software reuse
            |
            #Software reliability engineering concepts
            #Software reliability, system reliability and failure behavior
            #Fault lifecycle concepts and techniques
            |
            #Role of formal specification and analysis techniques in the software development cycle
            #Program assertion languages and analysis approaches (including languages for writing and analyzing pre- and post-conditions, such as OCL, JML)
            #Formal approaches to software modeling and analysis
            #Tools in support of formal methods
            |
            #Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections; Datapath + Control + Memory)
            #Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms
            #Application-level sequential processing: single thread
            #Simple application-level parallel processing: request level (web services/client-server/distributed), single thread per server, multiple threads with multiple servers
            #Basic concept of pipelining, overlapped processing stages
            #Basic concept of scaling: going faster vs. handling larger problems
            |
            #Programming abstractions, interfaces, use of libraries
            #Distinction between Application and OS services, Remote Procedure Call
            #Application-Virtual Machine Interaction
            #Reliability
            |
            #Digital vs. Analog/Discrete vs. Continuous Systems
            #Simple logic gates, logical expressions, Boolean logic simplification
            #Clocks, State, Sequencing
            #Combinational Logic, Sequential Logic, Registers, Memories
            #Computers and Network Protocols as examples of state machine
            |
            #Sequential vs. parallel processing
            #Parallel programming vs. concurrent programming
            #Request parallelism vs. Task parallelism
            #Client-Server/Web Services, Thread (Fork-Join), Pipelining
            #Multicore architectures and hardware support for synchronization
            |
            #Performance figures of merit
            #Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit
            #CPI (Cycles per Instruction) equation as tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations
            #Amdahls Law: the part of the computation that cannot be sped up limits the effect of the parts that can
            |
            #Kinds of resources ( processor share, memory, disk, net bandwidth)
            #Kinds of scheduling ( first-come, priority)
            #Advantages of fair scheduling, preemptive scheduling
            |
            #Speed of light and computers (one foot per nanosecond vs. one GHz clocks)
            #Latencies in computer systems: memory vs. disk latencies vs. across the network memory
            #Caches and the effects of spatial and temporal locality on performance in processors and systems
            #Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture
            #Introduction into the processor memory hierarchy and the formula for average memory access time
            |
            #Rationale for protection and predictable performance
            #Levels of indirection, illustrated by virtual memory for managing physical memory resources
            #Methods for implementing virtual memory and virtual machines
            |
            #Distinction between bugs and faults
            #Redundancy through check and retry
            #Redundancy through redundant encoding (error correcting codes, CRC, FEC)
            #Duplication/mirroring/replicas
            #Other approaches to fault tolerance and availability
            |
            #Analytical tools to guide quantitative evaluation
            #Order of magnitude analysis (Big-Oh notation)
            #Analysis of slow and fast paths of a system
            #Events on their effect on performance ( instruction stalls, cache misses, page faults)
            #Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation
            #Microbenchmarking pitfalls
            |
            #Social implications of computing in a networked world
            #Impact of social media on individualism, collectivism and culture
            #Growth and control of the Internet
            #Often referred to as the digital divide, differences in access to digital technology resources and its resulting ramifications for gender, class, ethnicity, geography, and/or underdeveloped countries
            #Accessibility issues, including legal requirements
            #Context-aware computing
            |
            #Ethical argumentation
            #Ethical theories and decision-making
            #Moral assumptions and values
            |
            #Community values and the laws by which we live
            #The nature of professionalism including care, attention and discipline, fiduciary responsibility, and mentoring
            #Keeping up-to-date as a computing professional in terms of familiarity, tools, skills, legal and professional framework as well as the ability to self-assess and progress in the computing field
            #Professional certification, codes of ethics, conduct, and practice, such as the ACM/IEEE-CS, SE, AITP, IFIP and international societies
            #Accountability, responsibility and liability (e.g. software correctness, reliability and safety, as well as ethical confidentiality of cybersecurity professionals)
            #The role of the computing professional in public policy
            #Maintaining awareness of consequences
            #Ethical dissent and whistle-blowing
            #The relationship between regional culture and ethical dilemmas
            #Dealing with harassment and discrimination
            #Forms of professional credentialing
            #Acceptable use policies for computing in the workplace
            #Ergonomics and healthy computing environments
            #Time to market and cost considerations versus quality professional standards
            |
            #Philosophical foundations of intellectual property
            #Intellectual property rights
            #Intangible digital intellectual property (IDIP)
            #Legal foundations for intellectual property protection
            #Digital rights management
            #Copyrights, patents, trade secrets, trademarks
            #Plagiarism
            |
            #Philosophical foundations of privacy rights
            #Legal foundations of privacy protection
            #Privacy implications of widespread data collection for transactional databases, data warehouses, surveillance systems, and cloud computing
            #Ramifications of differential privacy
            #Technology-based solutions for privacy protection
            |
            #Reading, understanding and summarizing technical material, including source code and documentation
            #Writing effective technical documentation and materials
            #Dynamics of oral, written, and electronic team and group communication
            #Communicating professionally with stakeholders
            #Utilizing collaboration tools
            |
            #Being a sustainable practitioner by taking into consideration cultural and environmental impacts of implementation decisions (e.g. organizational policies, economic viability, and resource consumption)
            #Explore global social and environmental impacts of computer use and disposal
            #Environmental impacts of design choices in specific areas such as algorithms, operating systems, networks, databases, or human-computer interaction
            |
            #Prehistory - the world before 1946
            #History of computer hardware, software, networking
            #Pioneers of computing
            #History of the Internet
            |
            #Monopolies and their economic implications
            #Effect of skilled labor supply and demand on the quality of computing products
            #Pricing strategies in the computing domain
            #The phenomenon of outsourcing and off-shoring software development; impacts on employment and on economics
            #Consequences of globalization for the computer science profession
            #Differences in access to computing resources and the possible effects thereof
            #Cost/benefit analysis of jobs with considerations to manufacturing, hardware, software, and engineering implications
            #Cost estimates versus actual costs in relation to total costs
            #Entrepreneurship: prospects and pitfalls
            #Network effect or demand-side economies of scale
            #Use of engineering economics in dealing with finances
            |
            #Examples of computer crimes and legal redress for computer criminals
            #Social engineering, identity theft and recovery
            #Issues surrounding the misuse of access and breaches in security
            #Motivations and ramifications of cyber terrorism and criminal hacking, cracking
            #Effects of malware, such as viruses, worms and Trojan horses
            #Crime prevention strategies
            #Security policies
            """
